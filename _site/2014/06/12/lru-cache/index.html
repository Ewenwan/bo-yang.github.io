
<!DOCTYPE HTML>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:wb="http://open.weibo.com/wb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Least Recently Used(LRU) Cache | Bo's Blog</title>
  
  <meta name="author" content="Bo Yang" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <!--
  <link href="/assets/themes/clear/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  -->

  <!-- Bootstrap -->
  <link href="/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/assets/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

  <!-- font-awesome -->
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">

  <!-- Google Prettify -->
  <link href="/assets/google-code-prettify/desert.css" rel="stylesheet" type="text/css" media="all">
  <!-- Google Pretty end -->

  <link href="/assets/style/blog.css" rel="stylesheet">
  
  <script src="/assets/bootstrap/js/jquery-1.10.2.js"></script>
  <script src="/assets/bootstrap/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>

   <!-- navigation bar -->
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
				<a class="navbar-brand" href="/"><b>bo-yang</b></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li><a href="/archive.html"><b>Archive</b></a>
					</li>
					<li><a href="/tags.html"><b>Tags</b></a>
                    </li>
                    <li><a href="/about.html"><b>About</b></a>
                    </li>
                    <li><a href="/messages.html"><b>Messages</b></a>
                    </li>
				</ul>
				<ul class="nav navbar-nav pull-right">
		          <li>
		            <form class="navbar-form navbar-search" method="get" action="http://www.google.com/search" target="google_window">
		              <input id="g_search" type="text" class="search-query" placeholder="Search..." name="q" />
		              <input type="submit" name="btnG" style="display:none" id="searchsubmit" value="Search" />
		              <input type="hidden" name="ie" value="UTF-8" />
		              <input type="hidden" name="oe" value="UTF-8" />
		              <input type="hidden" name="hl" value="en-US" />
		              <input type="hidden" name="domains" value="http://bo-yang.github.io/" />
					  <input type="hidden" name="sitesearch" value="http://bo-yang.github.io/" />
					  <button type="submit" class="button button-rounded button-flat-blue">Go</button>
		            </form>
		          </li>
		        </ul>
            </div>
			<!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

  <div class="container">
    <div class="row" id="content-row">
      
<div class="page-header">
	<h1>Least Recently Used(LRU) Cache</h1>
	<p>
		<span class="glyphicon glyphicon-time"></span> Posted at &nbsp; 2014-06-12 &nbsp; &nbsp; by  <a href="/about.html"><strong>Bo Yang</strong></a> &nbsp; &nbsp; <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C%2FC%2B%2B" rel="nofollow">C/C++</a>
	</p>
</div>

<div class="col-lg-10">
	<div class="post paper">
		<p>According to <a href="https://oj.leetcode.com/problems/lru-cache/">LeetCode</a>:</p>

<blockquote>
  <p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: <code>get</code> and <code>set</code>.</p>
</blockquote>

<blockquote>
  <p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</p>
</blockquote>

<blockquote>
  <p><code>set(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
</blockquote>

<p>When dealing with (key, vlaue) pairs, the most straight-forward data structure is hashmap(map or unordered_map in C++). However, at least for C++, it is difficult to control the insertion of new items: (1) the position you can specify is just a hint and does not force the new element to be inserted at that position within the map/unordered_map container, and (2) there is no <code>push_back</code> or <code>push_front</code> methods provided for map/unordered_map. </p>

<p>So if you implement the LRU cache only using hashmap, you may find that the order of inserted/deleted items is a mess. If you at first insert 10 items(keys 0~9) into the LRU cache of size 10, then enter another 10 items(keys 10~19), you will find that old items are not replaced in order.</p>

<pre>
Initial LRU cache:
Key  Value
9: 54
8: 71
7: 49
6: 12
5: 42
4: 10
3: 37
2: 12
1: 35
0: 83

Erase pair &lt;9,54&gt;
Erase pair &lt;10,2&gt;
Erase pair &lt;8,71&gt;
Erase pair &lt;7,49&gt;
Erase pair &lt;6,12&gt;
Erase pair &lt;5,42&gt;
Erase pair &lt;15,87&gt;
Erase pair &lt;16,35&gt;
Erase pair &lt;17,72&gt;
Erase pair &lt;18,36&gt;

Updated LRU cache:
Key  Value
19: 61
4: 10
14: 20
3: 37
13: 72
2: 12
12: 4
1: 35
11: 53
0: 83
</pre>

<p>To fix the order issue, there are three candidates: <code>vector</code>, <code>list</code>, <code>queue</code>. Since queue doesn’t support deleting an item at arbitrary position and deleting an item requires O(n) time cost for vector, the best choice is list. List is flexible enough to support inserting items into any position and erazing an arbitrary item in constant time. </p>

<p>However, the potential issue for list is that searching for an item requires O(n) time. To find an item in list in constant time, the best way is constructing a hashmap to record the key and its corresponding address in list. In C++, the builtin(actually, from C++ STL) hashmap data structure is <code>unordered_map</code>.</p>

<p>In order to update the values in the cache according to keys, <code>list</code> also needs to record both keys and values. There are two data structures can be used: <code>pair&lt;int, int&gt;</code> or <code>struct{int key;int val;}</code>. There is a saying, when dealing with large data, the STL <code>pair</code> struct will be much slower than the self-defined <code>struct</code>, because <a href="http://stackoverflow.com/questions/1606894/stdpairint-int-vs-struct-with-two-ints">std::pair&lt;int, int&gt;::pair() constructor initializes the fields with default values and initializing requires writing to each field which requires a whole lot of memory accesses that are relatively time consuming</a>. But my tests showed that <strong>the <code>pair</code> implementation always performs better</strong>.</p>

<p>I implemented LRU cache using both <code>pair&lt;int, int&gt;</code> and <code>struct{int key;int val;}</code>, and I also tested the time cost on my Mac. When setting the LRU capacity to 100, with the same test code, the <code>pair&lt;int, int&gt;</code> implementation is faster.</p>

<pre>
macmini:LRU boyang$ time ./lru_pair
real	0m0.010s
user	0m0.007s
sys	0m0.003s

macmini:LRU boyang$ time ./lru_struct
real	0m0.020s
user	0m0.016s
sys	0m0.003s
</pre>

<p>When setting the LRU capacity to 10000:</p>

<pre>
macmini:LRU boyang$ time ./lru_pair
real	0m0.575s
user	0m0.547s
sys	0m0.003s
macmini:LRU boyang$ time ./lru_struct
real	0m0.584s
user	0m0.580s
sys	0m0.003s
</pre>

<p>When setting the LRU capacity to 100000:</p>
<pre>
macmini:LRU boyang$ time ./lru_pair
real	1m23.615s
user	1m23.509s
sys	0m0.079s
macmini:LRU boyang$ time ./lru_struct 
real	2m1.782s
user	2m1.552s
sys	0m0.167s
</pre>

<p>Following are my implementations of LRU cache. There is one tricky thing of implementing <code>set(key,value)</code>: if you check if the cache size surpasses the capacity for every input and move the <code>while</code> clause out of the <code>if</code> block, then your code won’t pass the LeetCode tests, and you will receive an error of exceeding time limit. I think the cache size checking should be trivial, but I still cannot really understand why it matters so much in large data tests.</p>

<p><code>struct</code> implementation:</p>

<pre><code>class LRUCache{
public:
	struct Node {
		int key;
		int val;
		Node(int k, int v):key(k),val(v) {}
	};

	LRUCache(int capacity) {
        cap=capacity;
    }

    int get(int key) {
		unordered_map&lt;int,list&lt;Node&gt;::iterator&gt;::iterator got=hash.find(key);
		if(got!=hash.end()) {
			// update key&amp;value
			Node ptr=*(got-&gt;second);
			cache.erase(got-&gt;second);
			cache.push_front(ptr);
			hash[key]=cache.begin();

			return ptr.val;
		} else {
			return -1;
		}
    }
    
    void set(int key, int value) {
		Node ptr(key, value);
		unordered_map&lt;int,list&lt;Node&gt;::iterator&gt;::iterator got=hash.find(key);
		if(got!=hash.end()) {
			cache.erase(got-&gt;second); // erase so as to update key&amp;value
			hash.erase(key);
		} else {
			// Assume that least recently used items are stored at the end of the cache
	        while(cache.size()&gt;=cap) {
				Node it=cache.back();
				//cout&lt;&lt;"Erase pair &lt;"&lt;&lt;key&lt;&lt;","&lt;&lt;it.val&lt;&lt;"&gt;"&lt;&lt;endl; // TEST ONLY
				hash.erase(it.key);
				cache.pop_back();
			}
		}

		cache.push_front(ptr);
		hash[key]=cache.begin();

    }

	void print() {
		cout&lt;&lt;"Key  Value"&lt;&lt;endl;
		for(auto&amp; x: cache)
			cout&lt;&lt;x.key&lt;&lt;": "&lt;&lt;x.val&lt;&lt;endl;
	}

private:
	list&lt;Node&gt; cache; // &lt;value&gt;
	unordered_map&lt;int,list&lt;Node&gt;::iterator&gt; hash; // &lt;key, iterator&gt;
	int cap;
};
</code></pre>

<p><code>pair</code> implementation:</p>

<pre><code>class LRUCache{
public:
    LRUCache(int capacity) {
        cap=capacity;
    }
    
    int get(int key) {
		unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt;::iterator got=hash.find(key);
		if(got!=hash.end()) {
			// update key&amp;value
			int val=got-&gt;second-&gt;second;
			cache.erase(got-&gt;second);
			cache.push_front(pair&lt;int,int&gt;(key,val));
			hash[key]=cache.begin();

			return val;
		} else {
			return -1;
		}
    }
    
    void set(int key, int value) {
		// Assume that least recently used items are stored at the end of the cache
		unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt;::iterator got=hash.find(key);
		if(got!=hash.end()) {
			cache.erase(got-&gt;second); // erase so as to update key&amp;value
			hash.erase(key);
		} else {
			while(cache.size()&gt;=cap) { // for big data, must run here
				pair&lt;int,int&gt; it=cache.back();
				//cout&lt;&lt;"Erase pair &lt;"&lt;&lt;it.first&lt;&lt;","&lt;&lt;it.second&lt;&lt;"&gt;"&lt;&lt;endl; // TEST ONLY
				hash.erase(it.first);
				cache.pop_back();
			}
		}

		cache.push_front(pair&lt;int,int&gt;(key,value));
		hash[key]=cache.begin();

    }

	void print() {
		cout&lt;&lt;"Key  Value"&lt;&lt;endl;
		for(auto&amp; x: cache)
			cout&lt;&lt;x.first&lt;&lt;": "&lt;&lt;x.second&lt;&lt;endl;
	}

private:
	list&lt;pair&lt;int,int&gt; &gt; cache; // &lt;key, value&gt;
	unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; hash; // &lt;key, iterator&gt;
	int cap;
};
</code></pre>

	</div>

	<div align="right">
        <div class="bshare-custom">
	<span class='st_facebook_large' displayText='Facebook'></span>
	<span class='st_googleplus_large' displayText='Google +'></span>
	<span class='st_twitter_large' displayText='Tweet'></span>
	<span class='st_sina_large' displayText='Sina'></span>
	<span class='st_linkedin_large' displayText='LinkedIn'></span>
	<span class='st_tumblr_large' displayText='Tumblr'></span>
	<span class='st_sharethis_large' displayText='ShareThis'></span>
	<span class='st_blogger_large' displayText='Blogger'></span>
	<span class='st_email_large' displayText='Email'></span>
</div>
<script type="text/javascript">var switchTo5x=true;</script>
<script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
<script type="text/javascript">stLight.options({publisher: "6e9cb968-ad78-4055-b1e7-1b7ab6751416", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

	</div>

	<!-- page link -->
    <div class="pager">
      <ul>
      
        <li class="previous"><a href="/2014/05/26/binary-tree-traversal" title="Binary Tree Operations">&larr; Previous</a></li>
      

      
        <li class="next"><a href="/2014/06/14/soduku" title="Check Soduku Solution">Next &rarr;</a></li>
      
      </ul>
    </div>

	<!--
	<div class="well">
		<script>
var linkwithin_site_id = 2140443;
</script>
<script src="http://www.linkwithin.com/widget.js"></script>
<a href="http://www.linkwithin.com/"><img src="http://www.linkwithin.com/pixel.png" alt="Related Posts Plugin for WordPress, Blogger..." style="border: 0" /></a>

	</div>
	-->
    <div class="well">
		


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'boyang'; // required: replace example with your forum shortname
     var disqus_identifier = '/2014/06/12/lru-cache';
    var disqus_url = 'http://bo-yang.github.com//2014/06/12/lru-cache';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




    </div>
</div>

<div class="col-lg-2">
	<div class="well">
		<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Right-side Ad -->
<ins class="adsbygoogle"
     style="display:inline-block;width:300px;height:600px"
     data-ad-client="ca-pub-1292710832620237"
     data-ad-slot="9707222500"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

	</div>
	<div class="well">
		<h4>Visitors</h4>
		<div class="tag_box">
			<script type="text/javascript" src="http://je.revolvermaps.com/2/2.js?i=493pvkdo4nt&amp;m=0&amp;s=130&amp;c=ff0000&amp;t=1" async="async"></script>
	
		</div>
    </div>

</div>




    </div>

    <footer>
        <p>&copy; 2007 <span id="now_year"></span> Bo Yang. </p>
        <script type="text/javascript">
          var now_year = new Date().getFullYear();
          if (now_year != 2007) {
              $('#now_year').html('- ' + now_year);
          }
	    </script>
      </footer>
  </div>

  <script type="text/javascript" src="/assets/google-code-prettify/prettify.js"></script>
  <script src="/assets/run_prettify.js"></script>
  <script type="text/javascript">
    $(function() {

      $('a[href^="http"]').each(function () {
        $(this).attr('target', '_blank');
      });

      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
      window.prettyPrint && prettyPrint();

      function traverse($node, len, maxCount) {
        var reachMaxCount = len > maxCount;
        if (reachMaxCount) {
          $node.hide();
        }
        var $contents = $node.contents();
        for (var i = 0; i < $contents.length; ++i) {
          if (reachMaxCount) {
            $contents.eq(i).hide();
            continue;
          }
          if ($contents[i].nodeType == 3) { // TextNode
            var tmp = len;
            var s = $contents[i].nodeValue;
            len += s.length;
            reachMaxCount = len > maxCount;
            if (reachMaxCount && $contents[i].parentNode.nodeName != 'A') {
              $contents[i].nodeValue = s.substring(0, maxCount - tmp);
            }
          }
          else if ($contents[i].nodeType == 1) { // Element
            len = traverse($contents.eq(i), len, maxCount);
          }
        }
        return len;
      }

      $('.post_at_index').each(function() {
        var count = traverse($(this), 0, 400);
        if (count > 400) {
          var thisUrl = $(this).siblings().first().children().attr('href');
          $(this).after('\n<a href="' + thisUrl + '" rel="nofollow" class="btn btn-primary" role="button">' + 'Read More &raquo;</a>');
        }
      });
    });
  </script>

  

</body>
</html>

