
<!DOCTYPE HTML>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:wb="http://open.weibo.com/wb">
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<head>
  <title>Binary Tree Traversal | Bo's Blog</title>
  
  <meta name="author" content="boyang" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">

  <!-- using baidu cdn instead
  <link href="/assets/themes/clear/bootstrap/css/bootstrap.min.css" rel="stylesheet" />
  -->
  <link href="http://libs.baidu.com/bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet">


  <!-- Google Prettify -->
  <link href="/assets/themes/clear/google-code-prettify/desert.css" rel="stylesheet" type="text/css" media="all">
  <!-- Google Pretty end -->

  <link href="/assets/themes/clear/css/style.css" rel="stylesheet" type="text/css" media="all" />
  <!-- using baidu cdn instead
  <script type="text/javascript" src="/static/js/jquery-1.8.3.min.js"></script>
  -->

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>

  <div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <div class="container">
        <a class="brand" href="/">bo-yang</a>
        <ul class="nav">
          <li><a href="/archive.html">Archive</a></li>
          <li><a href="/about.html">About</a></li>
          <li><a href="/messages.html">Messages</a></li>
        </ul>
        <ul class="pull-right">
          <li>
            <form class="navbar-search" method="get" action="http://www.google.com/search" target="google_window">
              <input id="g_search" type="text" class="search-query" placeholder="Search..." name="q" />
              <input type="submit" name="btnG" style="display:none" id="searchsubmit" value="Search" />
              <input type="hidden" name="ie" value="UTF-8" />
              <input type="hidden" name="oe" value="UTF-8" />
              <input type="hidden" name="hl" value="en-US" />
              <input type="hidden" name="domains" value="http://bo-yang.github.io/" />
              <input type="hidden" name="sitesearch" value="http://bo-yang.github.io/" />
            </form>
          </li>
        </ul>
        <ul class="nav pull-right">
          <li><a href="/atom.xml">RSS</a></li>
        </ul>
      </div>
    </div>
  </div>

  <div class="container page-container">
    <div class="content">
      
<div class="page-header">
  <h1>Binary Tree Traversal</h1>
</div>

<div class="row-fluid page-body">
  <div class="span9 left">
    <div class="main-container shadow">
      <div class="mainbody thepost">
        <p>There are two kinds of traversal for (binary) trees: Depth First Search(DFS) and Breadth First Search(BFS). Depth First Search visits the tree by proceeding deeper and deeper until it reaches the leaf nodes, including pre-order, in-order, and post-order tree traversal. DFS uses a data structure called Stack.</p>

<p>Breadth First Search is the most natural solution for level-order traversal, since it visits the nodes level by level. BFS requires the use of a data structure called Queue, which is a First In First Out (FIFO) structure.</p>

<p>For the complete C++ source code used in this article, please refer to: <a href="https://github.com/bo-yang/misc/blob/master/BTtraverse.cc">https://github.com/bo-yang/misc/blob/master/BTtraverse.cc</a>.</p>

<h3 id="data-structure">Data Structure</h3>

<p>The data structure used for binary tree is very simple, which is adopted from <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode OJ</a>:</p>

<pre><code>struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
	TreeNode() : val(0), left(NULL), right(NULL) {}
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre>

<p>The constructing function TreeNode() is added to purely because it is easier to dynamically allocate TreeNode array by <code>new TreeNode[size]</code>. C++98 doesn’t support specifying default arguments for objects allocated by <code>new</code>. However, the TreeNode array can simplify the process of building binary trees. </p>

<h3 id="build-binary-tree">Build Binary Tree</h3>

<p>In my implementation, binary trees are built from a vector of strings. For example, given sequence {1,2,3,#,#,4,#,#,5}, the following binary tree can be built:</p>

<pre>
	  1
	 / \
	2   3
	   /
	  4
	   \
	    5
</pre>

<p>The tree is built layer by layer, where the first element in sequence is viewed as the root node. Here the “#” is used as terminator. </p>

<p>For each node other than the last layer, there are two children in the next layer, either a number(or string) or a “#”(invalid node). When parsing nodes in current layer, count the number of elements in next layer. The exception is for “#”s - they have no child nodes. In this way, we can parse the dependency of nodes layer by layer. </p>

<p>Following is the C++ code for building binary trees:</p>

<pre><code>TreeNode* BuildTree(vector&lt;string&gt;&amp; t) {
	tree=new TreeNode[t.size()];

	// Build binary tree from vector of strings, where # denotes an invalid node.
	//
	// The main idea is to parse vector of strings(nodes) layer by layer. 
	// The first item in the vector should be the root node, and the number of
	// first layer is one. When parsing the first layer, count the nodes of the
	// second layer, and so on.
	int idx=0;
	int nodes_cur_layer=1;
	vector&lt;string&gt;::iterator it=t.begin(); 
	while(idx&lt;t.size()) {
		int nodes_next_layer=0; // all nodes, including #s
		int vi=0;	// index of valid nodes in current layer
		for(int i=0;i&lt;nodes_cur_layer;++i) {
			if(*(it+i)=="#") { // Skip #s
				continue;
			}

			int left=nodes_cur_layer+2*vi;
			int right=nodes_cur_layer+2*vi+1;
			if(idx+left&lt;t.size() &amp;&amp; *(it+left)!="#" ) {
				tree[idx+i].left=&amp;tree[idx+left];
			} else {
				tree[idx+i].left=NULL;
			}
			if(idx+right&lt;t.size() &amp;&amp; *(it+right)!="#") {
				tree[idx+i].right=&amp;tree[idx+right];
			} else {
				tree[idx+i].right=NULL;
			}

			nodes_next_layer+=2;
			tree[idx+i].val=atoi((it+i)-&gt;c_str());
			vi++;
		}

		idx+=nodes_cur_layer;
		it+=nodes_cur_layer;
		nodes_cur_layer=nodes_next_layer;
		layers++;
	}

	return &amp;tree[0];	// root of the tree
}
</code></pre>

<h3 id="preorder-traversal">Preorder Traversal</h3>

<p>To traverse a binary tree in Preorder, following operations are carried-out 
1. Visit the root, 
2. Traverse the left subtree, and 
3. Traverse the right subtree. </p>

<p>For the example binary tree {1,2,3,#,#,4,#,#,5}, the preorder traversal is:</p>

<p><code>
1,2,3,4,5
</code></p>

<p>Following is my C++ implementation of preorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<pre><code>vector&lt;int&gt; PreorderTraversal(TreeNode *root) {
	vector&lt;int&gt; trace;
	stack&lt;TreeNode*&gt; st;
	while(root!=NULL) {
		trace.push_back(root-&gt;val); // Visit the root
		if(root-&gt;left!=NULL) {	// Traverse the left subtree
			TreeNode* tmp=root;
			root=root-&gt;left;
			if(tmp-&gt;right!=NULL)
				st.push(tmp-&gt;right);	// store the root of the right subtree
		} else if(root-&gt;right!=NULL) {
			root=root-&gt;right;
		} else {
			if(st.empty()) {
				root=NULL;
			} else {
				root=st.top();
				st.pop();
			}
		}
	} // end of while
	return trace;
}
</code></pre>

<h3 id="inorder-traversal">Inorder Traversal</h3>

<p>To traverse a binary tree in Inorder, following operations are carried-out:
1. Traverse the leftmost subtree starting at the left external node,
2. Visit the root, and 
3. Traverse the right subtree starting at the left external node.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,#,5}, the inorder traversal is:</p>

<p><code>
2,1,4,5,3
</code></p>

<p>Following is my C++ implementation of inorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<pre><code>vector&lt;int&gt; InorderTraversal(TreeNode *root) {
	vector&lt;int&gt; trace;
	stack&lt;TreeNode&gt; st;
    while(root!=NULL) {
		// Find the left-most node
		if(root-&gt;left!=NULL) {
			TreeNode tmp=*root;
			root=root-&gt;left;
			tmp.left=NULL;
			st.push(tmp);	// store the root of the right subtree
		} else if(root-&gt;right!=NULL) {
			// Handle the right subtree
			trace.push_back(root-&gt;val); // Visit leftmost node
			root=root-&gt;right;
		} else {
			trace.push_back(root-&gt;val); // Visit leaf/root node
			if(st.empty()) {
				root=NULL;
			} else {
				root=&amp;(st.top());
				st.pop();
			}
		}
	}
	return trace;
}
</code></pre>

<h3 id="postorder-traversal">Postorder Traversal</h3>

<p>To traverse a binary tree in Postorder, following operations are carried-out: 
1. Traverse all the left external nodes starting with the leftmost subtree which is then followed by bubble-up all the internal nodes, 
2. Traverse the right subtree starting at the left external node which is then followed by bubble-up all the internal nodes, and 
3. Visit the root.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,#,5}, the postorder traversal is:</p>

<p><code>
2,5,4,3,1
</code></p>

<p>Following is my C++ implementation of postorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<pre><code>vector&lt;int&gt; PostorderTraversal(TreeNode *root) {
	vector&lt;int&gt; trace;
	stack&lt;TreeNode&gt; st;
    while(root!=NULL) {
		// Find the left-most node
		if(root-&gt;left!=NULL) {
			TreeNode tmp=*root;
			root=root-&gt;left;
			tmp.left=NULL;
			st.push(tmp);	// store the root of the right subtree
		} else if(root-&gt;right!=NULL) {
			TreeNode tmp=*root;
			root=root-&gt;right;
			tmp.left=NULL;
			tmp.right=NULL;
			st.push(tmp);	// store the root
		} else {
			trace.push_back(root-&gt;val);	// Print root at last
			if(st.empty()) {
				root=NULL;
			} else {
				root=&amp;(st.top());
				st.pop();
			}
		}
	}
	return trace;
}
</code></pre>

<h3 id="breadth-first-traversalbft">Breadth First Traversal(BFT)</h3>

<p>Breadth first traversal is used for printing the binary tree in my code. The key of for BFT is to use a queue(s) to store nodes in current and/or next layers. The simplest way to use two queues: one to store nodes of current layer and the other for next layer. </p>

<p>However, a single queue also can work well. For the first layer, there is only one node - the root. When accessing this node, count the number of nodes in the second layer and push them into queue. When accessing the second layer, pop items in FIFO sequence and remove them from queue, and push the nodes in third layer into queue, and so on. Two inteher variables can be used to count the numbers of nodes in current layer and the next layer, respectively.</p>

<p>Following is my C++ impementation of traversing binary tree in level order:</p>

<pre><code>void PrintTree(TreeNode *root) {
	queue&lt;TreeNode*&gt; q;
	TreeNode* tmp=root;
	q.push(tmp);
	int nodes_cur_layer=1; // # of nodes in current layer
	int nodes_next_layer=0;	// # of nodes in next layer
	while(nodes_cur_layer&gt;0) {
		for(int i=0;i&lt;nodes_cur_layer;++i) {
			tmp=q.front();
			q.pop();

			cout&lt;&lt;tmp-&gt;val&lt;&lt;" ";

			if(tmp-&gt;left!=NULL) {
				q.push(tmp-&gt;left);
				nodes_next_layer++;
			}
			if(tmp-&gt;right!=NULL) {
				q.push(tmp-&gt;right);
				nodes_next_layer++;
			}
		}
		cout&lt;&lt;endl;
		nodes_cur_layer=nodes_next_layer;
		nodes_next_layer=0;
	}
}
</code></pre>

<h3 id="references">References</h3>
<ol>
  <li>https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</li>
  <li><a href="http://datastructuresnotes.blogspot.com/2009/02/binary-tree-traversal-preorder-inorder.html">Binary tree traversal: Preorder, Inorder, and Postorder</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Tree_traversal">Tree Traversal</a></li>
</ol>

      </div>
    </div>

    <div class="main-container shadow">
      <div class="mainbody">
        <div class="bshare-custom">
	<span class='st_facebook_large' displayText='Facebook'></span>
	<span class='st_googleplus_large' displayText='Google +'></span>
	<span class='st_twitter_large' displayText='Tweet'></span>
	<span class='st_sina_large' displayText='Sina'></span>
	<span class='st_linkedin_large' displayText='LinkedIn'></span>
	<span class='st_tumblr_large' displayText='Tumblr'></span>
	<span class='st_sharethis_large' displayText='ShareThis'></span>
	<span class='st_blogger_large' displayText='Blogger'></span>
	<span class='st_email_large' displayText='Email'></span>
</div>
<script type="text/javascript">var switchTo5x=true;</script>
<script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
<script type="text/javascript">stLight.options({publisher: "6e9cb968-ad78-4055-b1e7-1b7ab6751416", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

        
        <div class="post-end">
</div>


        <div class="pagination">
          <ul>
          
            <li class="prev"><a href="/2014/04/30/fisher-vector-in-action-recognition" title="Action Recognition with Fisher Vectors">&larr; Previous</a></li>
          
            <li><a href="/archive.html">Archive</a></li>
          
            <li class="next disabled"><a>Next &rarr;</a>
          
          </ul>
        </div>
      </div>
    </div>

    <div class="main-container shadow">
      <div class="mainbody">
		


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'boyang'; // required: replace example with your forum shortname
     var disqus_identifier = '/2014/05/26/binary-tree-traversal';
    var disqus_url = 'http://bo-yang.github.com//2014/05/26/binary-tree-traversal';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




	  </div>
    </div>

  </div>

  <div class="span3 right">
    <div class="side-container shadow">
      <div class="sidebar">
        <h4>Published</h4>
        <div class="date"><span>2014-05-26</span></div>
      </div>
    </div>

    <div class="side-container shadow">
      <div class="sidebar">
        
          <h4>Tags</h4>
          <ul class="tag_box">
          
          


  
     
    	<li><a href="/tags.html#Algorithm-ref">Algorithm <span>8</span></a></li>
     
    	<li><a href="/tags.html#C/C++-ref">C/C++ <span>2</span></a></li>
    
  



          </ul>
        
      </div>
    </div>

    <div class="side-container shadow">
		<div class="sidebar">
			<!--
			<script type="text/javascript" id="wumiiRelatedItems"></script>
			-->
		  <script>
var linkwithin_site_id = 2140443;
</script>
<script src="http://www.linkwithin.com/widget.js"></script>
<a href="http://www.linkwithin.com/"><img src="http://www.linkwithin.com/pixel.png" alt="Related Posts Plugin for WordPress, Blogger..." style="border: 0" /></a>

      </div>
    </div>

  </div>
</div>




    </div>

    <footer>
        <p>&copy; 2007 <span id="now_year"></span> boyang. </p>
        <script type="text/javascript">
          var now_year = new Date().getFullYear();
          if (now_year != 2007) {
              $('#now_year').html('- ' + now_year);
          }
        </script>
      </footer>
  </div>

  <script type="text/javascript" src="/assets/themes/clear/google-code-prettify/prettify.js"></script>
  <script type="text/javascript">
    $(function() {

      $('a[href^="http"]').each(function () {
        $(this).attr('target', '_blank');
      });

      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
      window.prettyPrint && prettyPrint();

      function traverse($node, len, maxCount) {
        var reachMaxCount = len > maxCount;
        if (reachMaxCount) {
          $node.hide();
        }
        var $contents = $node.contents();
        for (var i = 0; i < $contents.length; ++i) {
          if (reachMaxCount) {
            $contents.eq(i).hide();
            continue;
          }
          if ($contents[i].nodeType == 3) { // TextNode
            var tmp = len;
            var s = $contents[i].nodeValue;
            len += s.length;
            reachMaxCount = len > maxCount;
            if (reachMaxCount && $contents[i].parentNode.nodeName != 'A') {
              $contents[i].nodeValue = s.substring(0, maxCount - tmp);
            }
          }
          else if ($contents[i].nodeType == 1) { // Element
            len = traverse($contents.eq(i), len, maxCount);
          }
        }
        return len;
      }

      $('.post_at_index').each(function() {
        var count = traverse($(this), 0, 200);
        if (count > 200) {
          var thisUrl = $(this).siblings().first().children().attr('href');
          $(this).after('\n<a href="' + thisUrl + '" rel="nofollow">' + 'Read More ...</a>');
        }
      });
    });
  </script>
  

</body>
</html>

