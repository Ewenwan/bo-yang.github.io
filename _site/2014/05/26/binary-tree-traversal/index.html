
<!DOCTYPE HTML>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:wb="http://open.weibo.com/wb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Binary Tree Operations | Bo's Blog</title>
  
  <meta name="author" content="Bo Yang" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <!--
  <link href="/assets/themes/clear/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  -->

  <!-- Bootstrap -->
  <link href="/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/assets/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

  <!-- font-awesome -->
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">

  <!-- Google Prettify -->
  <link href="/assets/google-code-prettify/desert.css" rel="stylesheet" type="text/css" media="all">
  <!-- Google Pretty end -->

  <link href="/assets/bootstrap/css/blog-home.css" rel="stylesheet">
  <link href="/assets/bootstrap/css/blog-post.css" rel="stylesheet">
  
  <script src="/assets/bootstrap/js/jquery-1.10.2.js"></script>
  <script src="/assets/bootstrap/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>

   <!-- navigation bar -->
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">Home</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li><a href="/archive.html">Archive</a>
                    </li>
                    <li><a href="/about.html">About</a>
                    </li>
                    <li><a href="/messages.html">Messages</a>
                    </li>
				</ul>
				<ul class="nav navbar-nav pull-right">
		          <li>
		            <form class="navbar-form navbar-search" method="get" action="http://www.google.com/search" target="google_window">
		              <input id="g_search" type="text" class="search-query" placeholder="Search..." name="q" />
		              <input type="submit" name="btnG" style="display:none" id="searchsubmit" value="Search" />
		              <input type="hidden" name="ie" value="UTF-8" />
		              <input type="hidden" name="oe" value="UTF-8" />
		              <input type="hidden" name="hl" value="en-US" />
		              <input type="hidden" name="domains" value="http://bo-yang.github.io/" />
					  <input type="hidden" name="sitesearch" value="http://bo-yang.github.io/" />
					  <button type="submit" class="button button-rounded button-flat-blue">Go</button>
		            </form>
		          </li>
		        </ul>
            </div>
			<!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

  <div class="container">
    <div class="row">
      
<div class="page-header">
	<h1>Binary Tree Operations</h1>
	<p class="lead">by  <a href="/about.html"><strong>Bo Yang</strong></a></p>
	<hr>
	<p>
		<span class="glyphicon glyphicon-time"></span> Posted at 2014-05-26 &nbsp; &nbsp;  <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
</div>

<div class="col-lg-10">
    <p>There are two kinds of traversal for (binary) trees: Depth First Search(DFS) and Breadth First Search(BFS). Depth First Search visits the tree by proceeding deeper and deeper until it reaches the leaf nodes, including pre-order, in-order, post-order tree traversal. DFS uses a data structure called Stack.</p>

<p>Breadth First Search is the most natural solution for level-order traversal, since it visits the nodes level by level. BFS requires the use of a data structure called Queue, which is a First In First Out (FIFO) structure.</p>

<p>For the complete C++ source code used in this article, please refer to: <a href="https://github.com/bo-yang/BinaryTree">https://github.com/bo-yang/BinaryTree</a>.</p>

<ol>
  <li><a href="#data_structure">Data Structure</a></li>
  <li><a href="#build_tree">Build Binary Tree</a></li>
  <li><a href="#preorder">Preorder Traversal</a></li>
  <li><a href="#inorder">Inorder Traversal</a></li>
  <li><a href="#postorder">Postorder Traversal</a></li>
  <li><a href="#bft">Breadth First Traversal</a></li>
  <li><a href="#zigzag">Zigzag Traversal</a></li>
  <li><a href="#comparison">Binary Tree Comparison</a></li>
</ol>

<h3 id="a-namedatastructuredata-structurea"><a name="data_structure">Data Structure</a></h3>

<p>The data structure used for the tree node is very simple, which is adopted from <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode OJ</a>:</p>

<pre><code>struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
</code></pre>

<strike>The constructing function TreeNode() is added to purely because it is easier to dynamically allocate TreeNode array by `new TreeNode[size]`. C++98 doesn't support specifying default arguments for objects allocated by `new`. However, the TreeNode array can simplify the process of building binary trees.</strike>

<p>The data structure for the binary tree is:</p>

<pre><code>class BinaryTree {
public:
	BinaryTree() { root=NULL;layers=0; }
	BinaryTree(vector&lt;string&gt;&amp; t) { BuildTree(t); }
	~BinaryTree();
	TreeNode* GetRoot() { return root; }
	vector&lt;int&gt; PreorderTraversal(TreeNode *root);
	vector&lt;int&gt; InorderTraversal(TreeNode *root);
	vector&lt;int&gt; PostorderTraversal(TreeNode *root);
	vector&lt;vector&lt;int&gt; &gt; ZigzagLevelOrder(TreeNode *root);
	void PrintTraversal(vector&lt;int&gt;&amp; vec, string type);
	void PrintTraversal(vector&lt;vector&lt;int&gt; &gt;&amp; vec, string type);
	TreeNode* BuildTree(vector&lt;string&gt;&amp; t);
	void PrintTree(TreeNode *root);
	bool IsSameTree(TreeNode *p, TreeNode *q);

private:
	TreeNode* root;
	int layers;	// number of layers
};
</code></pre>

<h3 id="a-namebuildtreebuild-binary-treea"><a name="build_tree">Build Binary Tree</a></h3>

<p>In my implementation, binary trees are built from a vector of strings. For example, given sequence {1,2,3,#,#,4,#,#,5}, the following binary tree can be built:</p>

<pre>
	  1
	 / \
	2   3
	   /
	  4
	 / \
	5   6
</pre>

<p>The tree is built layer by layer, where the first element in sequence is viewed as the root node. Here the “#” is used as terminator. </p>

<p>For each node other than the last layer, there are two children in the next layer, either a number(or string) or a “#”(invalid node). When parsing nodes in current layer, count the number of elements in next layer. The exception is for “#”s - they have no child nodes. In this way, we can parse the dependency of nodes layer by layer. </p>

<p>Following is the C++ code for building binary trees:</p>

<pre><code>TreeNode* BuildTree(vector&lt;string&gt;&amp; t) {
	if(t.empty())
		return NULL;

	root=new TreeNode(-1);
	TreeNode* tree=root;
	queue&lt;TreeNode*&gt; q; // store nodes of next layer
	q.push(tree);

	// Build binary tree from vector of strings, where # denotes an invalid node.
	// The main idea is to parse vector of strings(nodes) layer by layer. 
	// The first item in the vector should be the root node, and the number of
	// first layer is one. When parsing the first layer, count the nodes of the
	// second layer, and so on.
	int idx=0;
	int nodes_cur_layer=1;
	vector&lt;string&gt;::iterator it=t.begin(); 
	while(idx&lt;t.size()){
		int nodes_next_layer=0; // all nodes, including #s
		int vi=0;	// index of valid nodes in next layer
		for(int i=0;i&lt;nodes_cur_layer;++i) {
			if(idx+i&lt;t.size() &amp;&amp; *(it+i)=="#") { // Skip #s
				continue;
			}

			tree=q.front();
			q.pop();

			int left=nodes_cur_layer+nodes_next_layer;
			int right=nodes_cur_layer+nodes_next_layer+1;
			if(idx+left&lt;t.size()) { // in case of out-of-boundary access
				if(*(it+left)!="#" ) {
					tree-&gt;left=new TreeNode(-1);
					q.push(tree-&gt;left);
					vi++;
				} else {
					tree-&gt;left=NULL;
				}
				nodes_next_layer++;
			}
			if(idx+right&lt;t.size()) { // in case of out-of-boundary access
				if(*(it+right)!="#") {
					tree-&gt;right=new TreeNode(-1);
					q.push(tree-&gt;right);
					vi++;
				} else {
					tree-&gt;right=NULL;
				}
				nodes_next_layer++;
			}

			tree-&gt;val=atoi((it+i)-&gt;c_str());
		}

		idx+=nodes_cur_layer;
		it+=nodes_cur_layer;
		nodes_cur_layer=nodes_next_layer;
		layers++;
	}

	return root;	// root of the tree
}
</code></pre>

<p>In order to delete the memroy dynamically allocated in function BuildTree(), in the desctructor, every node in the tree should be traversed and deleted. For simplicity, layer-by-layer traversal is used.</p>

<pre><code>~BinaryTree() {
	if(root!=NULL) {
		// delete allocated nodes iteratively
		queue&lt;TreeNode*&gt; q;
		TreeNode* tmp=root;
		q.push(tmp);
		int nodes_cur_layer=1; // # of nodes in current layer
		int nodes_next_layer=0;	// # of nodes in next layer
		while(nodes_cur_layer&gt;0) {
			for(int i=0;i&lt;nodes_cur_layer;++i) {
				tmp=q.front();
				q.pop();

				if(tmp-&gt;left!=NULL) {
					q.push(tmp-&gt;left);
					nodes_next_layer++;
				}
				if(tmp-&gt;right!=NULL) {
					q.push(tmp-&gt;right);
					nodes_next_layer++;
				}

				delete tmp;
			}
			nodes_cur_layer=nodes_next_layer;
			nodes_next_layer=0;
		}
	}
}
</code></pre>

<h3 id="a-namepreorderpreorder-traversala"><a name="preorder">Preorder Traversal</a></h3>

<p>To traverse a binary tree in Preorder, following operations are carried-out 
1. Visit the root, 
2. Traverse the left subtree, and 
3. Traverse the right subtree. </p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the preorder traversal is:</p>

<p><code>
1,2,3,4,5,6
</code></p>

<p>Following is my C++ implementation of preorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<pre><code>vector&lt;int&gt; PreorderTraversal(TreeNode *root) {
	vector&lt;int&gt; trace;
	stack&lt;TreeNode*&gt; st;
	while(root!=NULL) {
		trace.push_back(root-&gt;val); // Visit the root
		if(root-&gt;left!=NULL) {	// Traverse the left subtree
			TreeNode* tmp=root;
			root=root-&gt;left;
			if(tmp-&gt;right!=NULL)
				st.push(tmp-&gt;right);	// store the root of the right subtree
		} else if(root-&gt;right!=NULL) {
			root=root-&gt;right;
		} else {
			if(st.empty()) {
				root=NULL;
			} else {
				root=st.top();
				st.pop();
			}
		}
	} // end of while
	return trace;
}
</code></pre>

<h3 id="a-nameinorderinorder-traversala"><a name="inorder">Inorder Traversal</a></h3>

<p>To traverse a binary tree in Inorder, following operations are carried-out:
1. Traverse the leftmost subtree starting at the left external node,
2. Visit the root, and 
3. Traverse the right subtree starting at the left external node.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the inorder traversal is:</p>

<p><code>
2,1,5,4,6,3
</code></p>

<p>Following is my C++ implementation of inorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<pre><code>vector&lt;int&gt; InorderTraversal(TreeNode *root) {
	vector&lt;int&gt; trace;
	stack&lt;TreeNode&gt; st;
    while(root!=NULL) {
		// Find the left-most node
		if(root-&gt;left!=NULL) {
			TreeNode tmp=*root;
			root=root-&gt;left;
			tmp.left=NULL;
			st.push(tmp);	// store the root of the right subtree
		} else if(root-&gt;right!=NULL) {
			// Handle the right subtree
			trace.push_back(root-&gt;val); // Visit leftmost node
			root=root-&gt;right;
		} else {
			trace.push_back(root-&gt;val); // Visit leaf/root node
			if(st.empty()) {
				root=NULL;
			} else {
				root=&amp;(st.top());
				st.pop();
			}
		}
	}
	return trace;
}
</code></pre>

<h3 id="a-namepostorderpostorder-traversala"><a name="postorder">Postorder Traversal</a></h3>

<p>To traverse a binary tree in Postorder, following operations are carried-out: 
1. Traverse all the left external nodes starting with the leftmost subtree which is then followed by bubble-up all the internal nodes, 
2. Traverse the right subtree starting at the left external node which is then followed by bubble-up all the internal nodes, and 
3. Visit the root.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the postorder traversal is:</p>

<p><code>
2,5,6,4,3,1
</code></p>

<p>Following is my C++ implementation of postorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<pre><code>vector&lt;int&gt; PostorderTraversal(TreeNode *root) {
	vector&lt;int&gt; trace;
	stack&lt;TreeNode&gt; st;
    while(root!=NULL) {
		// Find the left-most node
		if(root-&gt;left!=NULL) {
			TreeNode tmp=*root;
			root=root-&gt;left;
			tmp.left=NULL;
			st.push(tmp);	// store the root of the right subtree
		} else if(root-&gt;right!=NULL) {
			TreeNode tmp=*root;
			root=root-&gt;right;
			tmp.left=NULL;
			tmp.right=NULL;
			st.push(tmp);	// store the root
		} else {
			trace.push_back(root-&gt;val);	// Print root at last
			if(st.empty()) {
				root=NULL;
			} else {
				root=&amp;(st.top());
				st.pop();
			}
		}
	}
	return trace;
}
</code></pre>

<h3 id="a-namebftbreadth-first-traversalbfta"><a name="bft">Breadth First Traversal(BFT)</a></h3>

<p>Breadth first traversal is used for printing the binary tree in my code. The key of for BFT is to use a queue(s) to store nodes in current and/or next layers. The simplest way to use two queues: one to store nodes of current layer and the other for next layer. </p>

<p>However, a single queue also can work well. For the first layer, there is only one node - the root. When accessing this node, count the number of nodes in the second layer and push them into queue. When accessing the second layer, pop items in FIFO sequence and remove them from queue, and push the nodes in third layer into queue, and so on. Two inteher variables can be used to count the numbers of nodes in current layer and the next layer, respectively.</p>

<p>Following is my C++ impementation of traversing binary tree in level order:</p>

<pre><code>void PrintTree(TreeNode *root) {
	queue&lt;TreeNode*&gt; q;
	TreeNode* tmp=root;
	q.push(tmp);
	int nodes_cur_layer=1; // # of nodes in current layer
	int nodes_next_layer=0;	// # of nodes in next layer
	while(nodes_cur_layer&gt;0) {
		for(int i=0;i&lt;nodes_cur_layer;++i) {
			tmp=q.front();
			q.pop();

			cout&lt;&lt;tmp-&gt;val&lt;&lt;" ";

			if(tmp-&gt;left!=NULL) {
				q.push(tmp-&gt;left);
				nodes_next_layer++;
			}
			if(tmp-&gt;right!=NULL) {
				q.push(tmp-&gt;right);
				nodes_next_layer++;
			}
		}
		cout&lt;&lt;endl;
		nodes_cur_layer=nodes_next_layer;
		nodes_next_layer=0;
	}
}
</code></pre>

<h3 id="a-namezigzagzigzag-traversala"><a name="zigzag">Zigzag Traversal</a></h3>

<p>Zigzag level order traversal is a Breadth First Traversal(BFT). The procedure  of this traversal is (i) from left to right, (ii) then right to left for the next level, (iii) and alternate between). </p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the postorder traversal is:</p>

<p><code>
[[1],[3,2],[4],[6,5]]
</code></p>

<p>Although zigzag traversal is kind of BFT, it is not easy to use one or two queues to implement it, because you need to traverse every layer from left to right, and print nodes from right to left for some layers. Since I don’t want to use three queues(one to store the nodes of current layer, the other two store the left-to-right traversal of next layer, but one of them should be used for left-to-right traveral in next iteration and the other used for right-to-left printing), I implemented the zigzag traversal with two lists: one list to store the left-to-right traversal of current layer, and the other list for storing left-to-right traversal of next layer. During printing, the same list can be controlled to output nodes either from left to right or right to left without loosing any information(unlike queue, quque is not iterable).</p>

<p>Following is my code for zigzag traversal. Note that the output is a vector of vectors.</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; ZigzagLevelOrder(TreeNode *root) {
    vector&lt;vector&lt;int&gt; &gt; trace;
	list&lt;TreeNode*&gt; lst_cur;
	int next_layer_nodes=0;
	int cur_layer_nodes;
	bool l2r=true;
	if(root!=NULL) {
		cur_layer_nodes=1;
		lst_cur.push_back(root);
	}else{
		return trace;
	}

	// Use two lists for left to right traversal and vice versa: 
	// one list used for storing nodes of current layer, and the 
	// other used for storing nodes layer below.
	//
	// The binary tree will always be traversed from left to right 
	// for each layer, however, for every other layer, the nodes will
	// be printed from right to left.
	while(cur_layer_nodes&gt;0) {
		vector&lt;int&gt; subtr;
		list&lt;TreeNode*&gt; lst_next;
		list&lt;TreeNode*&gt;::iterator lr=lst_cur.begin();
		list&lt;TreeNode*&gt;::iterator rl=lst_cur.end();
		for(int i=0;i&lt;cur_layer_nodes;++i) {
			TreeNode* tn = *(lr);
			if(l2r) {
				subtr.push_back((*(lr))-&gt;val);
			} else {
				rl--; // lst_cur.end() points to undefined memory
				subtr.push_back((*(rl))-&gt;val);
			}
			
			if(tn-&gt;left!=NULL) {
				next_layer_nodes++;
				lst_next.push_back(tn-&gt;left);
			}

			if(tn-&gt;right!=NULL) {
				next_layer_nodes++;
				lst_next.push_back(tn-&gt;right);
			}

			lr++;
		} // end for
		trace.push_back(subtr);
		cur_layer_nodes=next_layer_nodes;
		next_layer_nodes=0;
		lst_cur=lst_next;
		l2r=!l2r;
	} // end while

	return trace;
}
</code></pre>

<h3 id="a-namecomparisonbinary-tree-comparisona"><a name="comparison">Binary Tree Comparison</a></h3>

<p>As for the comparison of two binary trees, only equality is considered. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. To implement this, two trees should be traversed at the same time using same traverse method. If for every pair of nodes, the values are equal, and both of them have left child and right child, then the two nodes are considered equal.</p>

<p>For simplicity, Breadth First Traversal is used in my implementation:</p>

<pre><code>bool IsSameTree(TreeNode *p, TreeNode *q) {
	bool same_tree=true;
    queue&lt;TreeNode*&gt; qp;
	queue&lt;TreeNode*&gt; qq;
	int cur_layer_nodes;
	int next_layer_nodes=0;
	if(p!=NULL &amp;&amp; q!=NULL) {
		cur_layer_nodes=1;
		qp.push(p);
		qq.push(q);
	} else if(p==NULL &amp;&amp; q==NULL) {
		return true;
	} else {
		return false;
	}

	// Traverse trees layer by layer
	while(cur_layer_nodes&gt;0) {
		next_layer_nodes=0;
		for(int i=0;i&lt;cur_layer_nodes;++i) {
			TreeNode* tp=qp.front();
			qp.pop();
			TreeNode* tq=qq.front();
			qq.pop();

			if((tp-&gt;val!=tq-&gt;val) || (tp-&gt;left==NULL) &amp;&amp; (tq-&gt;left!=NULL) || (tp-&gt;left!=NULL) &amp;&amp; (tq-&gt;left==NULL) || (tp-&gt;right==NULL) &amp;&amp; (tq-&gt;right!=NULL) || (tp-&gt;right!=NULL) &amp;&amp; (tq-&gt;right==NULL)) {
				same_tree=false;
				break;
			}

			if(tp-&gt;left!=NULL) {
				qp.push(tp-&gt;left);
				qq.push(tq-&gt;left);
				next_layer_nodes++;
			}

			if(tp-&gt;right!=NULL) {
				qp.push(tp-&gt;right);
				qq.push(tq-&gt;right);
				next_layer_nodes++;
			}
		} // end for
		cur_layer_nodes=next_layer_nodes;
		if(!same_tree)
			break;
	} // end while

	return same_tree;
}
</code></pre>

<p><em>[Updated 05/30/2014]</em></p>

<h3 id="references">References</h3>
<ol>
  <li>https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</li>
  <li><a href="http://datastructuresnotes.blogspot.com/2009/02/binary-tree-traversal-preorder-inorder.html">Binary tree traversal: Preorder, Inorder, and Postorder</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Tree_traversal">Tree Traversal</a></li>
</ol>


	<div align="right">
        <div class="bshare-custom">
	<span class='st_facebook_large' displayText='Facebook'></span>
	<span class='st_googleplus_large' displayText='Google +'></span>
	<span class='st_twitter_large' displayText='Tweet'></span>
	<span class='st_sina_large' displayText='Sina'></span>
	<span class='st_linkedin_large' displayText='LinkedIn'></span>
	<span class='st_tumblr_large' displayText='Tumblr'></span>
	<span class='st_sharethis_large' displayText='ShareThis'></span>
	<span class='st_blogger_large' displayText='Blogger'></span>
	<span class='st_email_large' displayText='Email'></span>
</div>
<script type="text/javascript">var switchTo5x=true;</script>
<script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
<script type="text/javascript">stLight.options({publisher: "6e9cb968-ad78-4055-b1e7-1b7ab6751416", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

	</div>

	<!-- page link -->
    <div class="pager">
      <ul>
      
        <li class="previous"><a href="/2014/04/30/fisher-vector-in-action-recognition" title="Action Recognition with Fisher Vectors">&larr; Previous</a></li>
      

      
        <li class="next"><a href="/2014/06/12/lru-cache" title="Least Recently Used(LRU) Cache">Next &rarr;</a></li>
      
      </ul>
    </div>

    <div class="well">
		


  <div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_developer = 1;
    var disqus_shortname = 'boyang'; // required: replace example with your forum shortname
     var disqus_identifier = '/2014/05/26/binary-tree-traversal';
    var disqus_url = 'http://bo-yang.github.com//2014/05/26/binary-tree-traversal';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




    </div>


</div>




    </div>

    <footer>
        <p>&copy; 2007 <span id="now_year"></span> Bo Yang. </p>
        <script type="text/javascript">
          var now_year = new Date().getFullYear();
          if (now_year != 2007) {
              $('#now_year').html('- ' + now_year);
          }
	    </script>
      </footer>
  </div>

  <script type="text/javascript" src="/assets/google-code-prettify/prettify.js"></script>
  <script src="/assets/run_prettify.js"></script>
  <script type="text/javascript">
    $(function() {

      $('a[href^="http"]').each(function () {
        $(this).attr('target', '_blank');
      });

      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
      window.prettyPrint && prettyPrint();

      function traverse($node, len, maxCount) {
        var reachMaxCount = len > maxCount;
        if (reachMaxCount) {
          $node.hide();
        }
        var $contents = $node.contents();
        for (var i = 0; i < $contents.length; ++i) {
          if (reachMaxCount) {
            $contents.eq(i).hide();
            continue;
          }
          if ($contents[i].nodeType == 3) { // TextNode
            var tmp = len;
            var s = $contents[i].nodeValue;
            len += s.length;
            reachMaxCount = len > maxCount;
            if (reachMaxCount && $contents[i].parentNode.nodeName != 'A') {
              $contents[i].nodeValue = s.substring(0, maxCount - tmp);
            }
          }
          else if ($contents[i].nodeType == 1) { // Element
            len = traverse($contents.eq(i), len, maxCount);
          }
        }
        return len;
      }

      $('.post_at_index').each(function() {
        var count = traverse($(this), 0, 400);
        if (count > 400) {
          var thisUrl = $(this).siblings().first().children().attr('href');
          $(this).after('\n<a href="' + thisUrl + '" rel="nofollow">' + 'Read More ...</a>');
        }
      });
    });
  </script>
  
  

</body>
</html>

