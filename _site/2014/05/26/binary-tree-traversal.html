<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Binary Tree Operations(I) &#8211; Bo's Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Bo&#39;s blog.">
    <meta name="author" content="Bo Yang">
    <meta name="keywords" content="Algorithm, C/C++">
    <link rel="canonical" href="http://www.bo-yang.net//2014/05/26/binary-tree-traversal">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for Bo's Blog" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?201602041831" type="text/css">

    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
      <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    

    <!-- Google Prettify -->
    <link href="http://www.bo-yang.net//assets/google-code-prettify/desert.css" rel="stylesheet" type="text/css" media="all">

    <!-- MathJax -->
    
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    

    <!-- Verifications -->
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Binary Tree Operations(I)">
    <meta property="og:description" content="Bo&#39;s blog.">
    <meta property="og:url" content="http://www.bo-yang.net//2014/05/26/binary-tree-traversal">
    <meta property="og:site_name" content="Bo&#39;s Blog">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="@bonnyang" />
    
    <meta name="twitter:title" content="Binary Tree Operations(I)" />
    <meta name="twitter:description" content="Bo's blog." />
    <meta name="twitter:url" content="http://www.bo-yang.net//2014/05/26/binary-tree-traversal" />

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">

    
    <script type="text/javascript">
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
       ga('create', 'UA-50551633-1', 'auto');
       ga('send', 'pageview');
    </script>
    
</head>

<body class="site">

	
		<div id="fb-root"></div>
		<script>(function(d, s, id) {
		  var js, fjs = d.getElementsByTagName(s)[0];
		  if (d.getElementById(id)) return;
		  js = d.createElement(s); js.id = id;
		  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.5&appId=";
		  fjs.parentNode.insertBefore(js, fjs);
		}(document, 'script', 'facebook-jssdk'));</script>
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
        <a href="http://www.bo-yang.net/" class="site-title"><b>Bo's Blog</b></a>
      <nav class="site-nav">
        
    

    

    
        <a href="/archive/">Archive</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    

    

    

    

    
        <a href="/tags/">Tags</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    
        <a href="/about/">About Me</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


    

    

    

    
        <a href="/contact/">Contact</a>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    


      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="social-icons-right">
    
      <a class="fa fa-github" href="https://github.com/bo-yang"></a>
    
    
    
      <a class="fa fa-stack-overflow" href="https://stackoverflow.com/users/boyang"></a>
    
    <a class="fa fa-rss" href="/feed.xml"></a>
    
      <a class="fa fa-twitter" href="https://twitter.com/bonnyang"></a>
    
    
    
    
    
      <a class="fa fa-envelope" href="mailto:bonny95@gmail.com"></a>
    
    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/boyanglink"></a>
    
    
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>Binary Tree Operations(I)</h1>
  <span class="post-meta">May 26, 2014</span><br>
  
  <span class="post-meta small">
  
    10 minute read
  
  </span>
</div>

<article class="post-content">
  <p><em>This is the first article on binary tree operations. For other topics on binary tree, please refer to:</em></p>

<ol>
  <li><a href="http://www.bo-yang.net/2014/05/26/binary-tree-traversal">Binary Tree Operations(I)</a></li>
  <li><a href="http://www.bo-yang.net/2014/08/16/binary-tree-ii">Binary Tree Operations(II)</a></li>
  <li><a href="http://www.bo-yang.net/2014/09/12/binary-tree-iii">Binary Tree Operations(III) - Convert a Binary Tree to Down-Right Representation</a></li>
  <li><a href="http://www.bo-yang.net/2014/10/09/is-valid-bst">Binary Tree Operations(IV) - Determine if a Binary Tree is a Binary Search Tree</a></li>
</ol>

<p>There are two kinds of traversal for (binary) trees: Depth First Search(DFS) and Breadth First Search(BFS). Depth First Search visits the tree by proceeding deeper and deeper until it reaches the leaf nodes, including pre-order, in-order, post-order tree traversal. DFS uses a data structure called Stack.</p>

<p>Breadth First Search is the most natural solution for level-order traversal, since it visits the nodes level by level. BFS requires the use of a data structure called Queue, which is a First In First Out (FIFO) structure.</p>

<p>For the complete C++ source code used in this article, please refer to: <a href="https://github.com/bo-yang/BinaryTree">https://github.com/bo-yang/BinaryTree</a>.</p>

<ol>
  <li><a href="#data_structure">Data Structure</a></li>
  <li><a href="#build_tree">Build Binary Tree</a></li>
  <li><a href="#preorder">Preorder Traversal</a></li>
  <li><a href="#inorder">Inorder Traversal</a></li>
  <li><a href="#postorder">Postorder Traversal</a></li>
  <li><a href="#bft">Breadth First Traversal</a></li>
  <li><a href="#zigzag">Zigzag Traversal</a></li>
  <li><a href="#comparison">Binary Tree Comparison</a></li>
</ol>

<h3 id="a-namedatastructuredata-structurea"><a name="data_structure">Data Structure</a></h3>

<p>The data structure used for the tree node is very simple, which is adopted from <a href="https://oj.leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode OJ</a>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="k">struct</span> <span class="n">TreeNode</span> <span class="p">{</span>
	    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
	    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
	    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>
	<span class="p">};</span>
</code></pre>
</div>

<strike>The constructing function TreeNode() is added to purely because it is easier to dynamically allocate TreeNode array by `new TreeNode[size]`. C++98 doesn't support specifying default arguments for objects allocated by `new`. However, the TreeNode array can simplify the process of building binary trees.</strike>

<p>The data structure for the binary tree is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="k">class</span> <span class="nc">BinaryTree</span> <span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">BinaryTree</span><span class="p">()</span> <span class="p">{</span> <span class="n">root</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span><span class="n">layers</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
		<span class="n">BinaryTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">BuildTree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="p">}</span>
		<span class="o">~</span><span class="n">BinaryTree</span><span class="p">();</span>
		<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">GetRoot</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span> <span class="p">}</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">PreorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">InorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">PostorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ZigzagLevelOrder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
		<span class="kt">void</span> <span class="n">PrintTraversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">string</span> <span class="n">type</span><span class="p">);</span>
		<span class="kt">void</span> <span class="n">PrintTraversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">,</span> <span class="n">string</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">TreeNode</span><span class="o">*</span> <span class="n">BuildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">);</span>
		<span class="kt">void</span> <span class="n">PrintTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
		<span class="n">bool</span> <span class="n">IsSameTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

	<span class="k">private</span><span class="o">:</span>
		<span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">layers</span><span class="p">;</span>	<span class="c1">// number of layers
</span>	<span class="p">};</span>
</code></pre>
</div>

<h3 id="a-namebuildtreebuild-binary-treea"><a name="build_tree">Build Binary Tree</a></h3>

<p>In my implementation, binary trees are built from a vector of strings. For example, given sequence {1,2,3,#,#,4,#,#,5}, the following binary tree can be built:</p>

<pre>
	  1
	 / \
	2   3
	   /
	  4
	 / \
	5   6
</pre>

<p>The tree is built layer by layer, where the first element in sequence is viewed as the root node. Here the “#” is used as terminator.</p>

<p>For each node other than the last layer, there are two children in the next layer, either a number(or string) or a “#”(invalid node). When parsing nodes in current layer, count the number of elements in next layer. The exception is for “#”s - they have no child nodes. In this way, we can parse the dependency of nodes layer by layer.</p>

<p>Following is the C++ code for building binary trees:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="n">TreeNode</span><span class="o">*</span> <span class="nf">BuildTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">root</span><span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tree</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
		<span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// store nodes of next layer
</span>		<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tree</span><span class="p">);</span>

		<span class="c1">// Build binary tree from vector of strings, where # denotes an invalid node.
</span>		<span class="c1">// The main idea is to parse vector of strings(nodes) layer by layer. 
</span>		<span class="c1">// The first item in the vector should be the root node, and the number of
</span>		<span class="c1">// first layer is one. When parsing the first layer, count the nodes of the
</span>		<span class="c1">// second layer, and so on.
</span>		<span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nodes_cur_layer</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">t</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> 
		<span class="k">while</span><span class="p">(</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
			<span class="kt">int</span> <span class="n">nodes_next_layer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="c1">// all nodes, including #s
</span>			<span class="kt">int</span> <span class="n">vi</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="c1">// index of valid nodes in next layer
</span>			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nodes_cur_layer</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">i</span><span class="o">&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">==</span><span class="s">"#"</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Skip #s
</span>					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">tree</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
				<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

				<span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="n">nodes_cur_layer</span><span class="o">+</span><span class="n">nodes_next_layer</span><span class="p">;</span>
				<span class="kt">int</span> <span class="n">right</span><span class="o">=</span><span class="n">nodes_cur_layer</span><span class="o">+</span><span class="n">nodes_next_layer</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">left</span><span class="o">&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// in case of out-of-boundary access
</span>					<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="n">left</span><span class="p">)</span><span class="o">!=</span><span class="s">"#"</span> <span class="p">)</span> <span class="p">{</span>
						<span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
						<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
						<span class="n">vi</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">nodes_next_layer</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="n">right</span><span class="o">&lt;</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// in case of out-of-boundary access
</span>					<span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="o">+</span><span class="n">right</span><span class="p">)</span><span class="o">!=</span><span class="s">"#"</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
						<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
						<span class="n">vi</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">nodes_next_layer</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">tree</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">=</span><span class="n">atoi</span><span class="p">((</span><span class="n">it</span><span class="o">+</span><span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">c_str</span><span class="p">());</span>
			<span class="p">}</span>

			<span class="n">idx</span><span class="o">+=</span><span class="n">nodes_cur_layer</span><span class="p">;</span>
			<span class="n">it</span><span class="o">+=</span><span class="n">nodes_cur_layer</span><span class="p">;</span>
			<span class="n">nodes_cur_layer</span><span class="o">=</span><span class="n">nodes_next_layer</span><span class="p">;</span>
			<span class="n">layers</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">root</span><span class="p">;</span>	<span class="c1">// root of the tree
</span>	<span class="p">}</span>
</code></pre>
</div>

<p>In order to delete the memroy dynamically allocated in function BuildTree(), in the desctructor, every node in the tree should be traversed and deleted. For simplicity, layer-by-layer traversal is used.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="o">~</span><span class="n">BinaryTree</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// delete allocated nodes iteratively
</span>			<span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
			<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tmp</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="kt">int</span> <span class="n">nodes_cur_layer</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// # of nodes in current layer
</span>			<span class="kt">int</span> <span class="n">nodes_next_layer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="c1">// # of nodes in next layer
</span>			<span class="k">while</span><span class="p">(</span><span class="n">nodes_cur_layer</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nodes_cur_layer</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tmp</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
					<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

					<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
						<span class="n">nodes_next_layer</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
						<span class="n">nodes_next_layer</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="k">delete</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">nodes_cur_layer</span><span class="o">=</span><span class="n">nodes_next_layer</span><span class="p">;</span>
				<span class="n">nodes_next_layer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre>
</div>

<h3 id="a-namepreorderpreorder-traversala"><a name="preorder">Preorder Traversal</a></h3>

<p>To traverse a binary tree in Preorder, following operations are carried-out 
1. Visit the root, 
2. Traverse the left subtree, and 
3. Traverse the right subtree.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the preorder traversal is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1,2,3,4,5,6
</code></pre>
</div>

<p>Following is my C++ implementation of preorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">PreorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">trace</span><span class="p">;</span>
		<span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">root</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span> <span class="c1">// Visit the root
</span>			<span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// Traverse the left subtree
</span>				<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tmp</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
				<span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span>
					<span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>	<span class="c1">// store the root of the right subtree
</span>			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">root</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">root</span><span class="o">=</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
					<span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="c1">// end of while
</span>		<span class="k">return</span> <span class="n">trace</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre>
</div>

<h3 id="a-nameinorderinorder-traversala"><a name="inorder">Inorder Traversal</a></h3>

<p>To traverse a binary tree in Inorder, following operations are carried-out:
1. Traverse the leftmost subtree starting at the left external node,
2. Visit the root, and 
3. Traverse the right subtree starting at the left external node.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the inorder traversal is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2,1,5,4,6,3
</code></pre>
</div>

<p>Following is my C++ implementation of inorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">InorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">trace</span><span class="p">;</span>
		<span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
	    <span class="k">while</span><span class="p">(</span><span class="n">root</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Find the left-most node
</span>			<span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">TreeNode</span> <span class="n">tmp</span><span class="o">=*</span><span class="n">root</span><span class="p">;</span>
				<span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
				<span class="n">tmp</span><span class="p">.</span><span class="n">left</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>	<span class="c1">// store the root of the right subtree
</span>			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// Handle the right subtree
</span>				<span class="n">trace</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span> <span class="c1">// Visit leftmost node
</span>				<span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">trace</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span> <span class="c1">// Visit leaf/root node
</span>				<span class="k">if</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">root</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">root</span><span class="o">=&amp;</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
					<span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">trace</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre>
</div>

<h3 id="a-namepostorderpostorder-traversala"><a name="postorder">Postorder Traversal</a></h3>

<p>To traverse a binary tree in Postorder, following operations are carried-out: 
1. Traverse all the left external nodes starting with the leftmost subtree which is then followed by bubble-up all the internal nodes, 
2. Traverse the right subtree starting at the left external node which is then followed by bubble-up all the internal nodes, and 
3. Visit the root.</p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the postorder traversal is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2,5,6,4,3,1
</code></pre>
</div>

<p>Following is my C++ implementation of postorder traversal(<a href="http://en.wikipedia.org/wiki/Tree_traversal#Implementations">Pseudo Code</a>):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">PostorderTraversal</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">trace</span><span class="p">;</span>
		<span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">st</span><span class="p">;</span>
	    <span class="k">while</span><span class="p">(</span><span class="n">root</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Find the left-most node
</span>			<span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">TreeNode</span> <span class="n">tmp</span><span class="o">=*</span><span class="n">root</span><span class="p">;</span>
				<span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
				<span class="n">tmp</span><span class="p">.</span><span class="n">left</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>	<span class="c1">// store the root of the right subtree
</span>			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">TreeNode</span> <span class="n">tmp</span><span class="o">=*</span><span class="n">root</span><span class="p">;</span>
				<span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
				<span class="n">tmp</span><span class="p">.</span><span class="n">left</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="n">tmp</span><span class="p">.</span><span class="n">right</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>	<span class="c1">// store the root
</span>			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">trace</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>	<span class="c1">// Print root at last
</span>				<span class="k">if</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">root</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">root</span><span class="o">=&amp;</span><span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
					<span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">trace</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre>
</div>

<h3 id="a-namebftbreadth-first-traversalbfta"><a name="bft">Breadth First Traversal(BFT)</a></h3>

<p>Breadth first traversal is used for printing the binary tree in my code. The key of for BFT is to use a queue(s) to store nodes in current and/or next layers. The simplest way to use two queues: one to store nodes of current layer and the other for next layer.</p>

<p>However, a single queue also can work well. For the first layer, there is only one node - the root. When accessing this node, count the number of nodes in the second layer and push them into queue. When accessing the second layer, pop items in FIFO sequence and remove them from queue, and push the nodes in third layer into queue, and so on. Two inteher variables can be used to count the numbers of nodes in current layer and the next layer, respectively.</p>

<p>Following is my C++ impementation of traversing binary tree in level order:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="kt">void</span> <span class="nf">PrintTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span>
		<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tmp</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
		<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">nodes_cur_layer</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// # of nodes in current layer
</span>		<span class="kt">int</span> <span class="n">nodes_next_layer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>	<span class="c1">// # of nodes in next layer
</span>		<span class="k">while</span><span class="p">(</span><span class="n">nodes_cur_layer</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nodes_cur_layer</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tmp</span><span class="o">=</span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
				<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	
				<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="s">" "</span><span class="p">;</span>
	
				<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
					<span class="n">nodes_next_layer</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
					<span class="n">nodes_next_layer</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
			<span class="n">nodes_cur_layer</span><span class="o">=</span><span class="n">nodes_next_layer</span><span class="p">;</span>
			<span class="n">nodes_next_layer</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre>
</div>

<h3 id="a-namezigzagzigzag-traversala"><a name="zigzag">Zigzag Traversal</a></h3>

<p>Zigzag level order traversal is a Breadth First Traversal(BFT). The procedure  of this traversal is (i) from left to right, (ii) then right to left for the next level, (iii) and alternate between).</p>

<p>For the example binary tree {1,2,3,#,#,4,#,5,6}, the postorder traversal is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[[1],[3,2],[4],[6,5]]
</code></pre>
</div>

<p>Although zigzag traversal is kind of BFT, it is not easy to use one or two queues to implement it, because you need to traverse every layer from left to right, and print nodes from right to left for some layers. Since I don’t want to use three queues(one to store the nodes of current layer, the other two store the left-to-right traversal of next layer, but one of them should be used for left-to-right traveral in next iteration and the other used for right-to-left printing), I implemented the zigzag traversal with two lists: one list to store the left-to-right traversal of current layer, and the other list for storing left-to-right traversal of next layer. During printing, the same list can be controlled to output nodes either from left to right or right to left without loosing any information(unlike queue, quque is not iterable).</p>

<p>Following is my code for zigzag traversal. Note that the output is a vector of vectors.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ZigzagLevelOrder</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">trace</span><span class="p">;</span>
		<span class="n">list</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">lst_cur</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">next_layer_nodes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cur_layer_nodes</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">l2r</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">root</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_layer_nodes</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">lst_cur</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="k">return</span> <span class="n">trace</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// Use two lists for left to right traversal and vice versa: 
</span>		<span class="c1">// one list used for storing nodes of current layer, and the 
</span>		<span class="c1">// other used for storing nodes layer below.
</span>		<span class="c1">//
</span>		<span class="c1">// The binary tree will always be traversed from left to right 
</span>		<span class="c1">// for each layer, however, for every other layer, the nodes will
</span>		<span class="c1">// be printed from right to left.
</span>		<span class="k">while</span><span class="p">(</span><span class="n">cur_layer_nodes</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">subtr</span><span class="p">;</span>
			<span class="n">list</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">lst_next</span><span class="p">;</span>
			<span class="n">list</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">lr</span><span class="o">=</span><span class="n">lst_cur</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
			<span class="n">list</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">rl</span><span class="o">=</span><span class="n">lst_cur</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">cur_layer_nodes</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tn</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">lr</span><span class="p">);</span>
				<span class="k">if</span><span class="p">(</span><span class="n">l2r</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">subtr</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">lr</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">rl</span><span class="o">--</span><span class="p">;</span> <span class="c1">// lst_cur.end() points to undefined memory
</span>					<span class="n">subtr</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">rl</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
				<span class="p">}</span>
				
				<span class="k">if</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">next_layer_nodes</span><span class="o">++</span><span class="p">;</span>
					<span class="n">lst_next</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="k">if</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">next_layer_nodes</span><span class="o">++</span><span class="p">;</span>
					<span class="n">lst_next</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">lr</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="c1">// end for
</span>			<span class="n">trace</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">subtr</span><span class="p">);</span>
			<span class="n">cur_layer_nodes</span><span class="o">=</span><span class="n">next_layer_nodes</span><span class="p">;</span>
			<span class="n">next_layer_nodes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">lst_cur</span><span class="o">=</span><span class="n">lst_next</span><span class="p">;</span>
			<span class="n">l2r</span><span class="o">=!</span><span class="n">l2r</span><span class="p">;</span>
		<span class="p">}</span> <span class="c1">// end while
</span>
		<span class="k">return</span> <span class="n">trace</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre>
</div>

<h3 id="a-namecomparisonbinary-tree-comparisona"><a name="comparison">Binary Tree Comparison</a></h3>

<p>As for the comparison of two binary trees, only equality is considered. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. To implement this, two trees should be traversed at the same time using same traverse method. If for every pair of nodes, the values are equal, and both of them have left child and right child, then the two nodes are considered equal.</p>

<p>For simplicity, Breadth First Traversal is used in my implementation:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	<span class="n">bool</span> <span class="nf">IsSameTree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">same_tree</span><span class="o">=</span><span class="nb">true</span><span class="p">;</span>
        <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">qp</span><span class="p">;</span>
		<span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">qq</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cur_layer_nodes</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">next_layer_nodes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">!=</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cur_layer_nodes</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">qp</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="n">qq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// Traverse trees layer by layer
</span>		<span class="k">while</span><span class="p">(</span><span class="n">cur_layer_nodes</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next_layer_nodes</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">cur_layer_nodes</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tp</span><span class="o">=</span><span class="n">qp</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
				<span class="n">qp</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
				<span class="n">TreeNode</span><span class="o">*</span> <span class="n">tq</span><span class="o">=</span><span class="n">qq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
				<span class="n">qq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

				<span class="k">if</span><span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">val</span><span class="o">!=</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">==</span><span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">same_tree</span><span class="o">=</span><span class="nb">false</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">qp</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
					<span class="n">qq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
					<span class="n">next_layer_nodes</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">qp</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
					<span class="n">qq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">tq</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
					<span class="n">next_layer_nodes</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="c1">// end for
</span>			<span class="n">cur_layer_nodes</span><span class="o">=</span><span class="n">next_layer_nodes</span><span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">same_tree</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="c1">// end while
</span>
		<span class="k">return</span> <span class="n">same_tree</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre>
</div>

<p><em>[Updated 05/30/2014]</em></p>

<h3 id="references">References</h3>
<ol>
  <li>https://oj.leetcode.com/problems/binary-tree-inorder-traversal/</li>
  <li><a href="http://datastructuresnotes.blogspot.com/2009/02/binary-tree-traversal-preorder-inorder.html">Binary tree traversal: Preorder, Inorder, and Postorder</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Tree_traversal">Tree Traversal</a></li>
</ol>

</article>


  <div class="share-page">
  <br>
  Share this post!

  <div class="share-links">
    
      <a class="fa fa-facebook" href="https://facebook.com/sharer.php?u=http://www.bo-yang.net//2014/05/26/binary-tree-traversal" rel="nofollow" target="_blank" title="Share on Facebook"></a>
    

    
      <a class="fa fa-twitter" href="https://twitter.com/intent/tweet?text=Binary Tree Operations(I)&url=http://www.bo-yang.net//2014/05/26/binary-tree-traversal" rel="nofollow" target="_blank" title="Share on Twitter"></a>
    

    
      <a class="fa fa-google-plus" href="https://plus.google.com/share?url=http://www.bo-yang.net//2014/05/26/binary-tree-traversal" rel="nofollow" target="_blank" title="Share on Google+"></a>
    

    
      <a class="fa fa-linkedin" href="http://www.linkedin.com/shareArticle?url=http://www.bo-yang.net//2014/05/26/binary-tree-traversal&title=Binary Tree Operations(I)" rel="nofollow" target="_blank" title="Share on LinkedIn"></a>
    

    

    
      <a class="fa fa-tumblr" href="http://www.tumblr.com/share/link?url=http://www.bo-yang.net//2014/05/26/binary-tree-traversal&name=Binary Tree Operations(I)" rel="nofollow" target="_blank" title="Share on Tumblr"></a>
    

    
      <a class="fa fa-reddit" href="http://reddit.com/submit?url=http://www.bo-yang.net//2014/05/26/binary-tree-traversal&title=Binary Tree Operations(I)" rel="nofollow" target="_blank" title="Share on Reddit"></a>
    

    

    
      <a class="fa fa-hacker-news" onclick="parent.postMessage('submit','*')" href="https://news.ycombinator.com/submitlink?u=http://www.bo-yang.net//2014/05/26/binary-tree-traversal&t=Binary Tree Operations(I)" rel="nofollow" target="_blank" title="Share on Hacker News"></a>
    
  </div>
</div>





<center><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- Banner_728x90 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4220046549022535"
     data-ad-slot="5852972202"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</center>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-50551633-1', 'auto');
  ga('send', 'pageview');

</script>



  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_shortname  = 'boyang';
    var disqus_identifier = '/2014/05/26/binary-tree-traversal';
    var disqus_title      = 'Binary Tree Operations(I)';

    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



  <div class="fb-comments" data-href="http://www.bo-yang.net//2014/05/26/binary-tree-traversal" data-width="100%" data-numposts="10"></div>



  <h3 class="related-post-title">Related Posts</h3>
  
    <div class="post ml2">
      <a href="/2016/01/26/gen-hex-dump" class="post-link">
        <h4 class="post-title">Generate Wireshark-Understandable Hexdump</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/08/31/centos7-install-tftp-server" class="post-link">
        <h4 class="post-title">A Complete Guide For Installing TFTP Server In CentOS 7</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/08/20/linux-system-log-2" class="post-link">
        <h4 class="post-title">How To Use Local Facilities For Logging?</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/05/27/retrieve-last-log" class="post-link">
        <h4 class="post-title">Retrieve Last Log After Crash</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/04/02/customize-linux-system-log-timestamp" class="post-link">
        <h4 class="post-title">Customizing OpenWRT System Log Timestamp</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/03/30/debug-kernel-space-memory-leak" class="post-link">
        <h4 class="post-title">Debug Kernel Space Memory Leak</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/01/12/linux-system-log" class="post-link">
        <h4 class="post-title">Linux System Log</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2015/01/07/click-notes-click-language" class="post-link">
        <h4 class="post-title">Click Notes II - Click Script Language</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2014/12/23/click-notes-overview" class="post-link">
        <h4 class="post-title">Click Notes I - Overview</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  
    <div class="post ml2">
      <a href="/2014/12/19/remote-local-linux-develop-env-2" class="post-link">
        <h4 class="post-title">Building Remote+Local *nix Develop Environment(II)</h4>
        <p class="post-summary"></p>
      </a>
    </div>
  


      </div>
    </div>
  </div>

  <footer class="center">
    <div class="measure">
        <small>
            <p>&copy; 2007-2016 by <a href="http://www.bo-yang.net/">Bo Yang</a>. &nbsp; <script type="text/javascript" src="//rc.revolvermaps.com/0/0/3.js?i=493pvkdo4nt&amp;b=0&amp;s=20&amp;m=2&amp;cl=ffffff&amp;co=010020&amp;cd=aa0000&amp;v0=60&amp;v1=60&amp;r=1" async="async"></script>
 </p>

            <p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> and <a href="https://github.com/johnotander/pixyll">Pixyll</a>.</p>
        </small>
    </div>
</footer>

</body>
</html>
