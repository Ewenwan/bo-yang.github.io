
<!DOCTYPE HTML>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:wb="http://open.weibo.com/wb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bo Yang | Bo's Blog</title>
  
  <meta name="author" content="Bo Yang" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <!--
  <link href="/assets/themes/clear/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  -->

  <!-- Bootstrap -->
  <link href="/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/assets/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

  <!-- font-awesome -->
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">

  <!-- Google Prettify -->
  <link href="/assets/google-code-prettify/desert.css" rel="stylesheet" type="text/css" media="all">
  <!-- Google Pretty end -->

  <link href="/assets/style/blog.css" rel="stylesheet">
  
  <script src="/assets/bootstrap/js/jquery-1.10.2.js"></script>
  <script src="/assets/bootstrap/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>

   <!-- navigation bar -->
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
				<a class="navbar-brand" href="/"><b>bo-yang</b></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li><a href="/archive.html"><b>Archive</b></a>
					</li>
					<li><a href="/tags.html"><b>Tags</b></a>
                    </li>
                    <li><a href="/about.html"><b>About</b></a>
                    </li>
                    <li><a href="/messages.html"><b>Messages</b></a>
                    </li>
				</ul>
				<ul class="nav navbar-nav pull-right">
		          <li>
		            <form class="navbar-form navbar-search" method="get" action="http://www.google.com/search" target="google_window">
		              <input id="g_search" type="text" class="search-query" placeholder="Search..." name="q" />
		              <input type="submit" name="btnG" style="display:none" id="searchsubmit" value="Search" />
		              <input type="hidden" name="ie" value="UTF-8" />
		              <input type="hidden" name="oe" value="UTF-8" />
		              <input type="hidden" name="hl" value="en-US" />
		              <input type="hidden" name="domains" value="http://bo-yang.github.io/" />
					  <input type="hidden" name="sitesearch" value="http://bo-yang.github.io/" />
					  <button type="submit" class="button button-rounded button-flat-blue">Go</button>
		            </form>
		          </li>
		        </ul>
            </div>
			<!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

  <div class="container">
    <div class="row" id="content-row">
      
<div class="page-header">
	<h1>Bo Yang  <small style="margin-left:20px;"><font face="cursive"><i>Beginner's mind.</i></font></small></h1>
</div>

<div class="container">
    <div class="row" id="content-row">
		<div class="col-md-9">
	<!-- blog entry -->
	
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/21/merge-k-sorted-lists">Merge K Sorted Lists</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-21</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<h4 id="contents">Contents</h4>

<ol>
  <li><a href="#naive_method">Naive Method</a></li>
  <li><a href="#divide_conquer">Divide-and-Conquer Algorithm</a></li>
  <li><a href="#heap">Non-Recursive Method</a></li>
</ol>

<p>The <a href="https://oj.leetcode.com/problems/merge-k-sorted-lists/">Merge <code>k</code> Sorted Lists</a> is:</p>

<blockquote>
  <p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>

<p>In this problem, the sorted lists are stored in a vector, i.e. <code>vector&lt;ListNode*&gt;</code>. Assume the longest list contains <code>n</code> elements.</p>

<h3 id="a-namenaivemethodnaive-methoda"><a name="naive_method">Naive Method</a></h3>

<p>The naive method of merging <code>k</code> sorted lists is: iteratively compare the head elements of the <code>k</code> lists, find the smallest node, append this node to the merged list and forward that list by one step. Then repeat above step until all lists reach the end. Obviously, since in every iteration <code>k</code> comparisons are needed, and the longest list has <code>n</code> elements, therefore, the time complexity is \( O(k^{nk}) \) - the worst case is all lists have <code>n</code> elements, so for the total <code>nk</code> elements, totally \( k^{nk} \) comparisons are needed to merge them into one list.</p>

<h3 id="a-namedivideconquerdivide-and-conquer-algorithma"><a name="divide_conquer">Divide-and-Conquer Algorithm</a></h3>

<p>Other than exponential time complexity, a much better method is to use divide-and-conquer. Since merging two sorted lists is easy, we can recursively divide the <code>k</code> lists into two parts until there are no more than two lists. Then we can use a merge method similiar to the merge sort to merge the two lists together.</p>

<p>Assume the longest list contains <code>n</code> elements, the time required for dividing and merging lists is \( T(k)=2T(k/2)+O(nk) \). According to the Master Theorem, the time complexity is \( O(nk \log k) \). The space complexity of this algorithm is \( O(1) \).</p>

<p>Following is my C++ implementation of the divide-conquer method.</p>

<pre><code>class Solution {
public:
    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {
		if(lists.size()==0)
            return NULL;
        if(lists.size()==1)
            return lists[0];

		return divideConquerLists(lists,0,lists.size()-1);
    }

	ListNode* divideConquerLists(vector&lt;ListNode *&gt; &amp;lists, int start, int end) {
		if(start+1&lt;end) {
			int mid=(start+end)/2;
			ListNode* head1=divideConquerLists(lists,start,mid);
			ListNode* head2=divideConquerLists(lists,mid+1,end);
			return mergeTwoLists(head1,head2);
		} else if(start+1==end) {
			return mergeTwoLists(lists[start],lists[end]);
		} else if(start==end) {
			return lists[start];
		}
	}

	ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
		if(head1==NULL)
			return head2;
		if(head2==NULL)
			return head1;
	
		ListNode* pre_head=new ListNode(-1);
		ListNode* pre=pre_head;
		ListNode* node1=head1;
		ListNode* node2=head2;
		while(node1!=NULL &amp;&amp; node2!=NULL) {
			if(node1-&gt;val &lt; node2-&gt;val) {
				pre-&gt;next=node1;
				node1=node1-&gt;next;
			} else {
				pre-&gt;next=node2;
				node2=node2-&gt;next;
			}
			pre=pre-&gt;next;
		}
		while(node1!=NULL) {
			pre-&gt;next=node1;
			node1=node1-&gt;next;
			pre=pre-&gt;next;
		}
		while(node2!=NULL) {
			pre-&gt;next=node2;
			node2=node2-&gt;next;
			pre=pre-&gt;next;
		}
		pre-&gt;next=NULL;

		ListNode* head=pre_head-&gt;next;
		delete pre_head;

		return head;
	}
};
</code></pre>

<h3 id="a-nameheapnon-recursive-methoda"><a name="heap">Non-Recursive Method</a></h3>

<p>In addition to the recursive divide-conquer method, there is also a non-recursive method. We can use a maximum <code>k</code>-element heap(in C++, <code>priority_queue</code>) to merge the <code>k</code> lists. The strategy is:</p>

<ol>
  <li>Create a heap to store <code>ListNode*</code>, which should sort list nodes in the ascending order or node values.</li>
  <li>Insert the first node(head) of each list into the heap, so that we store all the <code>k</code> entries in the heap.</li>
  <li>Get the top element in heap and add in to the merged list.</li>
  <li>If the top element of heap is the last node in a list, pop it and go to step 3.</li>
  <li>If the top element of heap has followers, pop it and push its following node into heap. </li>
  <li>Go to step 3 until the heap is empty.</li>
</ol>

<p>To create a heap meet step’1 requirement, we need to create a structure/class that overloads the operator <code>()</code>, so that we can compare two list nodes based on their values. Such structure/class is required by the <code>priority_queue</code> template. Instead of a struct, I would rather use a lambda function to do so. Unfortunately, lambda function still cannot be used as the comparison object in <code>priority_queue</code>.</p>

<p>For a <code>k</code>-element <code>priority_queue</code>, an insertion requires \( O(\log k) \) time. Since we need to do such insertion for at most \(nk\) times, therefore the time complexity for this method is also \( O(nk \log k) \). Obviously, the space complexity of this algorithm is \( O(k) \).</p>

<pre><code>class Solution {
public:
	// comparison structure, required by priority_queue template
	struct greaterListNode{ 
		bool operator() (ListNode* x, ListNode* y) {return x-&gt;val &gt; y-&gt;val;}
	};

    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {
		if(lists.size()==0)
			return NULL;
		if(lists.size()==1)
			return lists[0];

		ListNode* pre_head=new ListNode(-1);
		ListNode* pre=pre_head;
		std::priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, greaterListNode&gt; pq;

		// Insert entries of every list into heap
		for(auto&amp; lst:lists)
			if(lst!=NULL)
				pq.push(lst);

		// Recursively parse every element in lists
		while(!pq.empty()) {
			pre-&gt;next=pq.top();
			pre=pre-&gt;next;
			pq.pop();

			if(pre!=NULL &amp;&amp; pre-&gt;next!=NULL)
				pq.push(pre-&gt;next);
		}

		ListNode* head=pre_head-&gt;next;
		delete pre_head;
		return head;
    }
};
</code></pre>

<h3 id="references">References:</h3>

<ol>
  <li><a href="http://blog.csdn.net/linhuanmars/article/details/19899259">Merge k Sorted Lists – LeetCode</a></li>
  <li><a href="http://www.cplusplus.com/reference/queue/priority_queue/">std::priority_queue</a></li>
  <li><a href="http://www.cplusplus.com/reference/functional/greater/">std::greater</a></li>
</ol>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/14/insertion-sort-list">Insertion Sort List</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-14</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/insertion-sort-list/">Insertion Sort List problem</a> is:</p>

<blockquote>
  <p>Sort a linked list using insertion sort.</p>
</blockquote>

<p>There is a very simple insertion sort method for arrays in Wikipedia.</p>

<pre><code>for i ← 1 to length(A)
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
</code></pre>

<p>The core of this algorithm is to find the position where to insert an smaller element. Compared to array, the list nodes cannot access nodes before them - they only know the nodes behind them. Therefore, instead of looking for insert positions decreasingly from current position down to the beginning, we can search the position from the head instead.</p>

<p>Following is my C++ implementation. Swapping two nodes is a little tricky, because you need to take care of four links.</p>

<pre><code>struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
 
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        if(head==NULL||head-&gt;next==NULL)
			return head;

		ListNode* pre_head=new ListNode(-1); // to manipulate the head
		pre_head-&gt;next=head;
		ListNode* cur=head;
		while(cur-&gt;next!=NULL) {
			if(cur-&gt;val &gt; cur-&gt;next-&gt;val) {
				ListNode* node=pre_head;

				// find position to insert
				while(node-&gt;next-&gt;val &lt; cur-&gt;next-&gt;val)
					node=node-&gt;next;

				// swap nodes
				ListNode* tmp1=node-&gt;next;
				ListNode* tmp2=cur-&gt;next-&gt;next;
				node-&gt;next=cur-&gt;next;
				cur-&gt;next-&gt;next=tmp1;
				cur-&gt;next=tmp2;
			} else {
				cur=cur-&gt;next;
			}
		}
		
		head=pre_head-&gt;next;
		delete pre_head;

		return head;
    }
};
</code></pre>

<p>In addition to above insertion sort, which moves smaller elements forward, we also can move the larger elments backward. The following code is more like bubble sort.</p>

<pre><code>ListNode *insertionSortList(ListNode *head) {
    if(head==NULL||head-&gt;next==NULL)
		return head;

	// find the length of the list
	int len=0;
	ListNode* node=head;
	while(node!=NULL) {
		node=node-&gt;next;
		len++;
	}

	// iteratively insert the largest number to the end
	for(int i=len-1;i&gt;=0;i--) {
		int j=0;
		node=head;
		ListNode* prev=NULL; // previous of node
		while(j&lt;i &amp;&amp; node!=NULL &amp;&amp; node-&gt;next!=NULL) {
			if(node-&gt;val &gt; node-&gt;next-&gt;val) {
				// swap nodes
				ListNode* tmp=node-&gt;next;
				node-&gt;next=node-&gt;next-&gt;next;
				tmp-&gt;next=node;
				if(j==0||prev==NULL) {
					head=tmp;
				} else {
					prev-&gt;next=tmp;
				}
				prev=tmp;
			} else {
				prev=node;
				node=node-&gt;next;
			}
			j++;
		}
	} // end for

	return head;
}
</code></pre>


	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/13/linked-list-cycle">Linked List Cycle Problems</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-13</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/linked-list-cycle/">Linked List Cycle problem</a> is:</p>

<blockquote>
  <p>Given a linked list, determine if it has a cycle in it. Can you solve it without using extra space?</p>
</blockquote>

<p>A <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">follow up problem</a> is:</p>

<blockquote>
  <p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.Can you solve it without using extra space? </p>
</blockquote>

<p>The first problem can be solved by the <strong><a href="http://www.geeksforgeeks.org/write-a-c-function-to-detect-loop-in-a-linked-list/">Floyd’s Cycle-Finding Algorithm</a></strong>:</p>

<blockquote>
  <p>Traverse linked list using two pointers: move one pointer by <em>one</em> and other pointer by <em>two</em>.  If these pointers meet at some node then there is a loop.  If pointers do not meet then linked list doesn’t have loop.</p>
</blockquote>

<p>As for the second problem, it is also based on the <strong>Floyd’s Cycle-Finding Algorithm</strong>. However, after detecting loop, we need to find the starting point of the cycle. <strong>The most convinient way is to use two pointers, one points to the head node, and the other points to the node that pointers meet when detecting loop. Then move both the two pointers by one respectively in each iteration, until they meet. The node they meet is the starting point of the cycle.</strong></p>

<p>Here is the detailed explanation of above trick(reference: <a href="http://www.cnblogs.com/TenosDoIt/p/3416702.html">http://www.cnblogs.com/TenosDoIt/p/3416702.html</a>). </p>

<ol>
  <li>Assume the length(number of nodes, the same below) of the list is <code>l</code>, the distance(number of nodes, the same below) between <code>head</code> and the starting point of cycle is <code>a</code>, the distance between the cycle-starting point and the point where the slow/fast pointers meet is <code>b</code>, and the length of the cycle is <code>r</code>.</li>
  <li>Assume when the fast/slow pointers meet, the slow pointer has accessed <code>s</code> nodes. Then the fast pointer has moved <code>2s</code>, and <code>s=a+b</code>.</li>
  <li>Since the nodes accessed by the fast pointer also calculated as <code>kr+s</code>, where <code>k</code> is the number of cycles and \( k \ge 1 \). We have <code>2s=kr+s</code>, i.e. <code>s=kr</code>.</li>
  <li>Since <code>s=a+b</code> and <code>s=kr</code>, we have <code>a+b=kr=(k-1)r+r</code>. Since <code>r=l-a</code>, we have <code>a+b=(k-1)+l-a</code>, i.e. <code>a=(k-1)+l-a-b</code>. Notice that <code>l-a-b</code> is the distance from the point where slow/fast pointers meet to the starting point of cycle(note: we only can go through the cycle of the linked list in one direction).</li>
  <li>Since <code>a</code> is the distance between <code>head</code> node and the starting point of cycle, <code>a=(k-1)+l-a-b</code> means that the distance between <code>head</code> node and the starting point of cycle(<code>a</code>) <em>equals</em> to the distance from the point where slow/fast pointers meet to the starting point of cycle(<code>l-a-b</code>) plus several loops of the cycle.</li>
  <li>Therefore, when we use two pointers to find the starting point of cycle, one pointer moves to the start point from the head of the list, while the other pointer winds aroung the cycle at the same pace. When the two pointers meet, one pointer must have moved <code>a</code> and the other moved <code>(k-1)+l-a-b</code>.</li>
</ol>

<p>Following is my C++ implmentation.</p>

<pre><code>class Solution {
public:
	ListNode *detectCycle(ListNode *head) {
		if(head==NULL || head-&gt;next==NULL)
			return NULL;

		ListNode* first=head;
		ListNode* second=head;
        while(first!=NULL &amp;&amp; second!=NULL &amp;&amp; second-&gt;next!=NULL) {
			first=first-&gt;next;
			second=second-&gt;next-&gt;next;

			if(first==second)
				break;
		}

		if(first==second) {
			// Continue walking X steps
			first = head;
			while(first!=second)
			{
	            first = first-&gt;next;
	            second = second-&gt;next;
	        }
	
			return second;
		} else {
			return NULL;
		}
    }

	// Create list with cycle using given vector of integers.
	// 	lb - the beginning index(in vec) of the cycle.
	ListNode* createList(vector&lt;int&gt;&amp; vec, int lb) {
		head=new ListNode(vec[0]);
		ListNode* node=head;
		ListNode* begin=NULL;
		for(int i=1;i&lt;vec.size();++i) {
			node-&gt;next=new ListNode(vec[i]);
			node=node-&gt;next;
			if(i==lb)
				begin=node;
		}
		if(lb&gt;0 &amp;&amp; lb&lt;vec.size())
			node-&gt;next=begin;
		else if(lb&gt;=vec.size()) // index out of upper bound, set to NULL
			node-&gt;next=NULL;
		else
			node-&gt;next=head; // index out of lower bound, linked to the head

		return head;
	}

	void printList(ListNode *head) {
		ListNode* node=head;
		while(node!=NULL) {
			cout&lt;&lt;node-&gt;val&lt;&lt;" ";
			node=node-&gt;next;
		}
		cout&lt;&lt;endl;
	}

	Solution() {head=NULL;}

	~Solution() {
		ListNode* node=head;
		while(head!=NULL){
			head=head-&gt;next;
			delete node;
			node=head;
		}
	}

private:
	ListNode* head;

};
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/08/sort-list">Sort List</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-08</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/sort-list/">The Sort List problem</a> is:</p>

<blockquote>
  <p>Sort a linked list in \( O(n log n) \) time using constant space complexity.</p>
</blockquote>

<p>The solution to this problem is modifying the array/vector based merge sort and make it work for lists. The key is finding the middle node of each list to be sorted. This can be achieved by two pointers: one points to the head of list(<code>mid</code>), and the other point to the next node of head(<code>end</code>). Then iteratively go through elements in the list - the <code>mid</code> pointer increase one position in each iteration, while the <code>end</code> pointer increased two positions. Thus when <code>end</code> pointer reached the end of the list, the <code>mid</code> pointer arrives at the middle of the list.</p>

<p>Following is my C++ implementation, which contains methods of creating list, printing list, sorting list and deleting allocated memory.</p>

<pre><code>struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
 
class Solution {
public:
    ListNode *sortList(ListNode *head) {
	   //cout&lt;&lt;"sorting list: "; // TEST ONLY
	   //printList(head); // TEST ONLY

       if(head==NULL || head-&gt;next==NULL) 
		   return head;

	   // Find the middle node of the list
	   ListNode* mid=head;
	   ListNode* end=head-&gt;next;
	   while(end!=NULL &amp;&amp; end-&gt;next!=NULL) {
		   mid=mid-&gt;next;
		   end=end-&gt;next-&gt;next;
	   }

	   ListNode* head_right=mid-&gt;next;
	   mid-&gt;next=NULL;
	   ListNode* head_left=sortList(head);
	   head_right=sortList(head_right);
	   head=mergeList(head_left,head_right);

	   //cout&lt;&lt;"merged lists: "; // TEST ONLY
	   //printList(head); // TEST ONLY

	   return head;
    }

	ListNode* mergeList(ListNode *head_left, ListNode *head_right) {
		if(head_left==NULL &amp;&amp; head_right==NULL)
			return NULL;

		// Determine the head
		ListNode* head=NULL;
		if(head_left==NULL || head_left-&gt;val &gt; head_right-&gt;val) {
			head=head_right; 
			head_right=head_right-&gt;next;
		} else {
			head=head_left;
			head_left=head_left-&gt;next;
		}

		// Merge lists in ascending order
		ListNode* node=head;
		while(head_left!=NULL &amp;&amp; head_right!=NULL) {
			if(head_left-&gt;val &lt; head_right-&gt;val) {
				node-&gt;next=head_left;
				head_left=head_left-&gt;next;
			} else {
				node-&gt;next=head_right;
				head_right=head_right-&gt;next;
			}
			node=node-&gt;next;
		}
		while(head_left!=NULL) {
			node-&gt;next=head_left;
			node=node-&gt;next;
			head_left=head_left-&gt;next;
		}
		while(head_right!=NULL) {
			node-&gt;next=head_right;
			node=node-&gt;next;
			head_right=head_right-&gt;next;
		}

		return head;
	}

	// Create list using given vector of integers
	ListNode* createList(vector&lt;int&gt;&amp; vec) {
		head=new ListNode(vec[0]);
		ListNode* node=head;
		for(int i=1;i&lt;vec.size();++i) {
			node-&gt;next=new ListNode(vec[i]);
			node=node-&gt;next;
		}

		return head;
	}

	void printList(ListNode *head) {
		ListNode* node=head;
		while(node!=NULL) {
			cout&lt;&lt;node-&gt;val&lt;&lt;" ";
			node=node-&gt;next;
		}
		cout&lt;&lt;endl;
	}

	Solution() {head=NULL;}

	~Solution() {
		ListNode* node=head;
		while(head!=NULL){
			head=head-&gt;next;
			delete node;
			node=head;
		}
	}

private:
	ListNode* head;
};
</code></pre>

<p>Following code can be used for testing the above solution:</p>

<pre><code>int main() {
	vector&lt;int&gt; vec={3,6,2,-1,4,7,4,11,9,20,8,-3,0};
	Solution sol;
	ListNode* head=sol.createList(vec);
	cout&lt;&lt;"Before sorting:"&lt;&lt;endl;
	sol.printList(head);
	
	head=sol.sortList(head);
	cout&lt;&lt;"After sorting:"&lt;&lt;endl;
	sol.printList(head);
}
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/07/subset-sum">Subset Sum Problem</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-07</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/3sum/">The 3Sum problem</a> is:</p>

<blockquote>
  <p>Given an array <code>S</code> of n integers, are there elements <code>a, b, c</code> in <code>S</code> such that <code>a + b + c = 0</code>? Find all unique triplets in the array which gives the sum of zero.</p>

  <p>Note:</p>

  <ul>
    <li>Elements in a triplet <code>(a,b,c)</code> must be in non-descending order. (ie, <code>a ≤ b ≤ c</code>)</li>
    <li>The solution set must not contain duplicate triplets.</li>
  </ul>
</blockquote>

<p>Inspired by the <a href="http://en.wikipedia.org/wiki/3SUM">Wikipedia solution</a>, I implemented following solution. The first step is sorting the array <code>S</code> in ascending order, so that we can guarantee the front elements in the array are not less than the elemts at the end of the array. Then for every number in array, we can use the two variables to go through the whole array to find the triplets summed to 0. </p>

<p>In order to guarantee there are no duplicate triplets, a hash table is used to record the triplets that have been found. Before inserting the newly found triplet into the solution matrix(<code>vector&lt;vector&lt;int&gt; &gt;</code>), try to look for the triplet in the hash table first. Since C++ doesn’t support <code>vector&lt;int&gt;</code> keys, I formulate string keys using the integer triplets in the following code.</p>

<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) {
		// Sort the vector
		std::sort(num.begin(), num.end());
		
		// Find triplets
		unordered_map&lt;string,bool&gt; map; // store found triplets
		char* buf=new char[100];
		for(int i=0;i&lt;num.size();++i) {
			vector&lt;int&gt; triplet;
			int hi=num.size()-1;
			int lo=0;
			while(hi&gt;i &amp;&amp; lo&lt;i) {
				if(num[i]+num[hi]+num[lo]==0) { // found a triplet
					sprintf(buf,"%d%d%d",num[i],num[hi],num[lo]);
					string str(buf);
					unordered_map&lt;string,bool&gt;::const_iterator got=map.find(str);
					if(got==map.end()) { // a brand new triplet
						triplet.push_back(num[lo]);
						triplet.push_back(num[i]);
						triplet.push_back(num[hi]);
						map[str]=true;
						sol.push_back(triplet);
					}
					triplet.clear();
					hi--;lo++;
				} else if(num[i]+num[hi]+num[lo]&gt;0) {
					hi--;
				} else { // &lt;0
					lo++;
				}
			}
		}
		delete [] buf;

		return sol;
    }
	
private:
	vector&lt;vector&lt;int&gt; &gt; sol;
};
</code></pre>


	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/07/determine-top-common-ip-addresses">Find Top Source IP Addresses in Distributed Systems</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-07</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Distributed Systems-ref" rel="nofollow">Distributed Systems</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Perl-ref" rel="nofollow">Perl</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Network-ref" rel="nofollow">Network</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The problem is:</p>

<blockquote>
  <p>Determines the top 10 most common source IP addresses, and their hit rates, for a fleet of 1000 web servers within the last hour.</p>

  <p>The following assumptions may be used…</p>

  <ul>
    <li>web servers are locally writing access logs in the <a href="http://httpd.apache.org/docs/current/logs.html#combined">Apache Combined Log Format</a>.</li>
    <li>web servers are accessible by <code>ssh</code>.</li>
  </ul>
</blockquote>

<p>My solution is:</p>

<ol>
  <li>For each server in the fleet, copy the <code>/var/log/httpd/access_log</code> to local directory by <code>ssh</code>.</li>
  <li>Given a access_log, for each line in the log, extract the IP address, time/time zone and status code. </li>
  <li>For lines written in the past hour, count the occurrences of each IP address(number of requests) and numbers of sucessful operations(status code 1xx,2xx and 3xx in my implementation).</li>
  <li>After counting logs of all servers, sort the IP addresses by their occurrences.</li>
  <li>For the top 10 IP addresses, calculate their hit rates using equation:
 <code>hit rate = (# of successful operations) / (# of all requests)</code></li>
</ol>

<p>Assumptions are:</p>

<ol>
  <li>The names of servers in the fleet are stored in a file, such as ‘fleet_servers’. The servers can be geographically distributed in different cities/countries.</li>
  <li>This script will be executed in a directory that can be read &amp; written by the user. </li>
  <li>The report of the top 10 most common IPs and hit rates will be stored in current directory.</li>
  <li>The SSH keys to remote servers have been generated and synced, so that there is no need to manually enter the passwords. </li>
  <li>Following Perl modules should be installed:
    <ul>
      <li><code>DateTime</code> - used to determine if the logs are older than 1 hour.</li>
      <li><code>Parallel::ForkManager</code> - check multiple logs in concurrently.</li>
    </ul>
  </li>
</ol>

<p>Following is my Perl implementation. For more information and the source file, please refer to <a href="https://github.com/bo-yang/CommonSourceIPs">https://github.com/bo-yang/CommonSourceIPs</a>.</p>

<pre><code>use strict;
use warnings;
use POSIX qw(strftime);
use DateTime;
use Parallel::ForkManager;
use Getopt::Long;
use FindBin qw($Bin);
use Cwd 'abs_path';

my $ldt=DateTime-&gt;now(); # Get UTC date time
my $input='fleet_servers'; # default file to store server list
my $output="report_".strftime("%Y%d%m_%H%M%S",localtime()); # default file t ostore report
my $login=`whoami`;
my $access_log='/var/log/httpd/access_log'; # the default location of the access log
my $time_range=1; # 1 hour by default
my $num_ips=10;	# number of the most common source IP addresses
my $num_process=30; # Max number of processes for parallel processing

GetOptions(
	'input|i=s'  =&gt; \$input,
	'output|o=s' =&gt; \$output,
	'login|l=s'  =&gt; \$login,
	'alog|a=s'   =&gt; \$access_log,
	'trange|t=i' =&gt; \$time_range,
	'num_ip|n=i' =&gt; \$num_ips,
	'process|p=i'=&gt; \$num_process,
	'help|?'	 =&gt; \&amp;ShowUsage
   ) or ShowUsage();


die("ERROR: no input reads specied!\n") if (!$input);

# Handle signals
my $CleanupDone   = 0;
$SIG{'ABRT'} = 'doCleanup';
$SIG{'HUP'}  = 'doCleanup';
$SIG{'INT'}  = 'doCleanup';
$SIG{'QUIT'} = 'doCleanup';

open IN, "&lt;$input" or die("ERROR: cannot open file $input!");

# Iteratively access each server. Assume that each line of the input file is 
# a server name or IP address.
my $clients={};
my $pm = new Parallel::ForkManager($num_process);
while (my $server = &lt;IN&gt;) {
	$pm-&gt;start and next; # do the fork

	chomp $server;
	my $tmplog=".${server}.access_log.tmp";
	`ssh ${login}@${server} "cat ${access_log}" &gt; $tmplog`;

	open LOG, "&lt;$tmplog" or die("ERROR: cannot open file $tmplog!");
	# Parse the access_log of this server
	while (my $line = &lt;LOG&gt;) {
		if($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) {
			my $ip=$1;
			my ($rdt, $stat_code)=($line =~ m/\[(.*)\].*" (\d{3})/);
	
			# Calculate time differece between local and remote servers(in seconds)
			my $time_diff=CompareTime($ldt,$rdt);
			# Skip messages older than specified time range
			next if($time_diff &gt; $time_range*3600);
	
			# Count requests and successful oprations
			if(not $clients-&gt;{$ip}){
				$clients-&gt;{$ip}-&gt;{'request'}=1;
				$clients-&gt;{$ip}-&gt;{'success'}=0;
			} else {
				$clients-&gt;{$ip}-&gt;{'request'}++;
			}
			# Only status code that begins with 1, 2 or 3 will be counted
			$clients-&gt;{$ip}-&gt;{'success'}++ if($stat_code =~ /[1-3]\d{2}/);
		} else {
			warn "No IP address found in ${tmplog}.";
		}
	}
	close LOG;
	unlink $tmplog; # remove temporary files

	$pm-&gt;finish;
}
$pm-&gt;wait_all_children; # wait for forked-processes

close IN;

# Find the most common IP addresses and calculate their hit rates
open OUT, "&gt;$output" or die("ERROR: cannot write file $output!");
print OUT "IP Address \t Hit Rate \t # Req \t # Succ\n";
print STDOUT "IP Address \t Hit Rate \t # Req \t # Succ\n";
my $cnt=0;
# Sort source IP addresses in descending order of requests
foreach my $ip (sort {$clients-&gt;{$b}-&gt;{'request'} &lt;=&gt; $clients-&gt;{$a}-&gt;{'request'}} keys %{$clients}) {
	# Calculate hit rate
	$clients-&gt;{$ip}-&gt;{'hit rate'}=$clients-&gt;{$ip}-&gt;{'success'}/$clients-&gt;{$ip}-&gt;{'request'};
	my $hit_rate=sprintf("%.4f",$clients-&gt;{$ip}-&gt;{'hit rate'});
	print OUT "$ip \t $hit_rate \t $clients-&gt;{$ip}-&gt;{'request'} \t $clients-&gt;{$ip}-&gt;{'success'}\n";
	print STDOUT "$ip \t $hit_rate \t $clients-&gt;{$ip}-&gt;{'request'} \t $clients-&gt;{$ip}-&gt;{'success'}\n";

	$cnt++;
	last if($cnt&gt;=$num_ips); # break out
}

close OUT;


#
# Compare two time and return the differences in seconds.
# 
# Inputs: 
# 	local time(array), remote time(string)
# Output: 
# 	time difference(in seconds)
#
sub CompareTime {
	my $ldt=$_[0]; # local time, array
	my $remote_dt=$_[1]; # remote time, string
	
	my %month_map = (
		'Jan' =&gt; 1, 'Feb' =&gt; 2, 'Mar' =&gt; 3,
		'Apr' =&gt; 4, 'May' =&gt; 5, 'Jun' =&gt; 6,
		'Jul' =&gt; 7, 'Aug' =&gt; 8, 'Sep' =&gt; 9,
		'Oct' =&gt; 10,'Sep' =&gt; 11,'Dec' =&gt; 12
	);

	my ($rday,$rmonth,$ryear,$rhour,$rmin,$rsec,$rtz)=($remote_dt =~ m/(\d+)\/(\S+)\/(\d+):(\d+):(\d+):(\d+) ([+-]\d+)/);
	my $rdt = DateTime-&gt;new(
		year	=&gt; $ryear,
		month	=&gt; $month_map{$rmonth},
		day		=&gt; $rday,
		hour	=&gt; $rhour,
		minute	=&gt; $rmin,
		second	=&gt; $rsec,
		time_zone =&gt; $ldt-&gt;time_zone,
	);

	# Convert the remote time into UTC time zone.
	my $ltz='+0000';
	if($ltz ne $rtz) {
		my $abs_rtz=$rtz;
		if($abs_rtz =~ m/[+-].*/) {
			$abs_rtz=substr $abs_rtz, 1; # remove the leading +/-
		}
		# The ISO 8601 offset from UTC in timezone linke +0700 (1 minute=1, 1 hour=100)
		my $tz_diff=$abs_rtz/100*3600; # time zone diff in seconds
		my $dur = DateTime::Duration-&gt;new(
			years       =&gt; 0,
	      	months      =&gt; 0,
	      	weeks       =&gt; 0,
	      	days        =&gt; 0,
	      	hours       =&gt; 0,
	      	minutes     =&gt; 0,
	      	seconds     =&gt; $tz_diff,
	      	nanoseconds =&gt; 0
		);
		# Add/subtract time zone influence
		if($rtz =~ /\-\d+/) {
			$rdt-&gt;add_duration($dur);
		} else {
			$rdt-&gt;subtract_duration($dur);
		}
	}
	
	# Calculate the absolute time differences in seconds
	my $time_diff=$ldt-&gt;subtract_datetime_absolute($rdt);
	return $time_diff-&gt;in_units('seconds');
}

#
# Show usgage
# 
sub ShowUsage {
	my $proc=`basename $0`;
	chomp($proc);

	print STDOUT "Usage: $proc [-i server_list] [-o report] [-l login] [-a access_log] [-t time_range] [-n ip_num] [-p process_num]\n";
	print STDOUT "where:\n";
	print STDOUT "  server_list\t - list of servers in the pool, optional\n";
	print STDOUT "  report\t - report file, optional \n";
	print STDOUT "  login\t\t - login to admin servers, optional\n";
	print STDOUT "  access_log\t - path of Apache access_log, optional\n";
	print STDOUT "  time_range\t - range of time to be analysed(unit: hour), optional\n";
	print STDOUT "  ip_num\t - number of the top source IPs, optional\n";
	print STDOUT "  process_num\t - number of concurrent processes, optional\n";
	
	exit;
}

#
# Clean up before exit
#
sub doCleanup {
	if($CleanupDone == 1) {
		exit;
	}

	`rm .*.access_log.tmp`; # remove temp files
	$CleanupDone = 1;
	exit 0;
} ## end sub doCleanup
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/06/longest-palindromic-substring">Longest Palindromic Substring</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-06</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring problem</a> is:</p>

<blockquote>
  <p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. </p>
</blockquote>

<p>To solve this problem, first investigate following examples:</p>

<ul>
  <li><code>abcdefedchz</code>: the longest palindrome is <code>cdefedc</code>, the left and right parts are symmetric to letter <code>f</code>.</li>
  <li><code>acbbcae</code>: the longest palindrome <code>acbbca</code>, which is symmetric to the (virtual) postion between <code>bb</code>.</li>
  <li><code>a</code>: the longest palindrome is the letter <code>a</code>.</li>
</ul>

<p>Based on above investigations, we could summarize the solution as: </p>

<ol>
  <li>For every letter in the string, find the longest repetitive characters to current letter, record the <code>start</code> and <code>end</code> position;</li>
  <li>Minus <code>start</code> position by one and see if <code>s[start]</code> is still identical to <code>s[end]</code>.</li>
  <li>If yes, iteratively compare <code>s[start--]</code> and <code>s[end--]</code> until they are not equal.</li>
  <li>The possible longest palindrome for current letter is <code>end-start-1</code>.</li>
</ol>

<p>Following is my C++ implementation. This algorithm could be enhanced by not checking every letters, however, the time complexity will still be \( O(N^2) \). A better method is <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring">Manacher’s Algorithm</a>, which has  \( O(N) \) time complexity.</p>

<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
		if(s.empty())
			return "";

        int pd_start=0; // the start position of the palindrome
		int pd_len=0; // the length of the palindrome
		for(int i=0;i&lt;s.length();++i) {
			int start=i;
			int end=i;
			while(end&lt;s.length() &amp;&amp; s[start]==s[end])
				end++;

			start--;
			while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s[start]==s[end]) {
				start--;
				end++;
			}
			
			if(pd_len&lt;end-start-1) {
				pd_len=end-start-1;
				pd_start=start+1;	
			}
		}

		return s.substr(pd_start,pd_len);		
    }
};
</code></pre>


	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/01/strstr">The First Occurrence of Needle In Haystack</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-01</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/implement-strstr/">The problem</a> is:</p>

<blockquote>
  <p>Implement strStr().</p>

  <p>Returns a pointer to the first occurrence of needle in haystack, or null if needle is not part of haystack.</p>
</blockquote>

<p>A naive method: (1) find the the first letter of <code>needle</code> in <code>haystack</code>, (2)comparing other consecutive characters of needle and haystack, (3) if all letters in <code>needle</code> can be found in <code>haystack</code> consecutively, then return the position in <code>haystack</code>.</p>

<pre><code>class Solution {
public:
    char *strStr(char *haystack, char *needle) {
		if(haystack==NULL || needle==NULL)
			return NULL;

		if(needle[0]=='\0')
			return haystack;

		// Find the first character of needle in haystack
		int hay_len=strlen(haystack);
		int need_len=strlen(needle);
		int pos=0;
		bool found=false;
		while(hay_len-pos&gt;=need_len &amp;&amp; haystack[pos]!='\0') {
			if(haystack[pos] == needle[0]){
				int th=pos+1;
				int tn=1;
				while(haystack[th] == needle[tn]) {
					if(needle[tn]=='\0')
						break;
					th++;
					tn++;
				}
				if(tn == need_len) {
					found=true;
					break;
				}
			}
			pos++;
		}

		if(found)
			return haystack+pos;
		else
			return NULL;
    }
};
</code></pre>

<p>A better solution is to use the famous KMP algorithm(<a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/">http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/</a>).</p>

<pre><code>class Solution {
public:
    char *strStr(char *haystack, char *needle) {
		if(haystack==NULL || needle==NULL)
	 		return NULL;
	 	if(needle[0]=='\0')
	 		return haystack;

		int n=strlen(haystack);
		int m=strlen(needle);
		vector&lt;int&gt; pi(m); // the longest proper prefix which is also suffix
		computePrefix(needle,pi);
		//printPrefix(pi); // TEST ONLY

		int q=0; // index for needle
		int i=0; // index for haystack
		while(i&lt;n) {
			//cout&lt;&lt;"needle["&lt;&lt;q&lt;&lt;"]="&lt;&lt;needle[q]&lt;&lt;", haystack["&lt;&lt;i&lt;&lt;"]="&lt;&lt;haystack[i]&lt;&lt;endl; // TEST ONLY
			if(needle[q]==haystack[i]) {
				q++;
				i++;
			}
			if(q==m) {
				//cout&lt;&lt;"Pattern occurs with shift "&lt;&lt;i-m&lt;&lt;endl; // TEST ONLY
				return haystack+i-m;
			} else if(needle[q]!=haystack[i]) {
				if(q!=0)
					q=pi[q-1];
				else
					i++;
			}
		}
		return NULL;
	}

	// Calculate the longest proper prefix which is also suffix.
	// Examples:
	// 	For the pattern “AABAACAABAA”, lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]
	//	For the pattern “ABCDE”, lps[] is [0, 0, 0, 0, 0]
	//	For the pattern “AAAAA”, lps[] is [0, 1, 2, 3, 4]
	//	For the pattern “AAABAAA”, lps[] is [0, 1, 2, 0, 1, 2, 3]
	//	For the pattern “AAACAAAAAC”, lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]
	void computePrefix(char* P, vector&lt;int&gt;&amp; pi) {
		int m=strlen(P);
		pi[0]=0; // lps[0] is always 0
		int k=0; // length of the previous prefix suffix
		int i=1;
		while(i&lt;m) {
			if(P[k]==P[i]) {
				k++;
				pi[i]=k;
				i++;
			} else {
				if(k!=0) {
					k=pi[k-1];
				} else {
					pi[i]=0;
					i++;
				}
			}
		}
	}

	void printPrefix(vector&lt;int&gt;&amp; pi) {
		cout&lt;&lt;"pi={ ";
		for(auto&amp; x:pi)
			cout&lt;&lt;x&lt;&lt;" ";
		cout&lt;&lt;"}"&lt;&lt;endl;
	}
};
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/01/longest-consecutive-sequence">Longest Consecutive Sequence</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-01</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/longest-consecutive-sequence/">The problem</a> is:</p>

<blockquote>
  <p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>

  <p>For example,</p>

  <p>Given <code>[100, 4, 200, 1, 3, 2]</code>,the longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Return its length: <code>4</code>.</p>

  <p>Your algorithm should run in \( O(n) \) complexity.</p>
</blockquote>

<p>The most intuitive solution to this problem is sorting the array first, and then go through the sorted array and record the length of the longest consecutive sequence. However, the time complexity of this method is \(O(n \log n)\). </p>

<p>In order to get the \( O(n) \) complexity, we can pick up the first element in array(say <code>num[0]</code>), and then check if <code>num[0]-1</code> and <code>num[0]+1</code> are in the array. If yes, iteratively check the upper/lower boundary of this sequence. Until the upper/lower boundaries never change, find a new element in the array that has not been accessed and start a new search. </p>

<p>In this solution, a hash table(<code>unordered_map</code> in C++) is needed to record the accessibility of each element in the array. The keys to the hash table are the integeres in the array, and the values are bool - if the key has been accessed, then set to <code>false</code>; otherwise set to <code>true</code>. In average, checking the existence(in C++, the <code>find()</code> of <code>unordered_map</code>) of a key in the hash table costs constant time. Since we only access every element in the array(or hash table) for only one time, and the operations for each element only cost \(O(1)\) time, the time complexity of this method is \( O(n) \). And the space complexity is also \( O(n) \) due to the hash table.</p>

<p>Following is my C++ implementation.</p>

<pre>
class Solution {
public:
    int longestConsecutive(vector<int> &amp;num) {
        unordered_map&lt;int,bool&gt; map;
		for(auto&amp; x:num)
			map[x]=true;
		
		int start=num[0];
		int end=num[0];
		int max_len=1;
		int cnt=1; // items have been accessed
		int idx=1;
		while(cnt&lt;=num.size()) {
			//cout&lt;&lt;"start="&lt;&lt;start&lt;&lt;", end="&lt;&lt;end&lt;&lt;endl; // TEST ONLY
			map[start]=false;
			map[end]=false;
			// Find the lower boundary
			unordered_map&lt;int,bool&gt;::iterator got=map.find(start-1);
			if(got!=map.end() &amp;&amp; got-&gt;second) { 
				start--;
				cnt++;
			}
			
			// Find the upper boundary
			got=map.find(end+1);
			if(got!=map.end() &amp;&amp; got-&gt;second) { 
				end++;
				cnt++;
			}

			if(max_len&lt;end-start+1)
				max_len=end-start+1;

			if(!(map[start]||map[end])) { 
				// If both start and end rich the boundaries, 
				// find a new entry for them.
				while(idx&lt;num.size() &amp;&amp; map[num[idx]]==false)
					idx++;
				start=num[idx];
				end=num[idx];
				map[start]=false;
				cnt++;
			}
		}

		return max_len;
    }
};

</int></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/06/29/top-n-numbers">Top N Numbers</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-06-29</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The problem is:</p>

<blockquote>
  <p>Given an arbitrarily large file and a number, \(N\), containing individual numbers on each line (e.g. 200Gb file), will output the largest \(N\) numbers, highest first. Analyse the run time/space complexity of your approach.</p>
</blockquote>

<p>The intuitive method for the top-\(N\) is to sort all numbers first, and then return the first/last \(N\) numbers. However, the time complexity of sorting is usually \(O(n \log n)\), and when the data are very big, it is impossible to do the sorting in memory directly.</p>

<p>Finding the top \(N\) items can be done in \(O(n \log N) \) time, which is approximate to \( O(n) \). The key is to use a heap(in C++, it is <em>priority_queue</em>) to store the top \(N\) items during reading the huge data. <a href="http://en.wikipedia.org/wiki/Heap_(data_structure)">Heap</a> is a specialized (binary) tree-based data structure that satisfies the <em>heap property</em>: either the keys of parent nodes are always greater than or equal to those of the children and the highest key is in the root node (this kind of heap is called max heap) or the keys of parent nodes are less than or equal to those of the children and the lowest key is in the root node (min heap).</p>

<p>The strategy is:</p>

<ul>
  <li>maintain an \(N\)-item long heap, and read all items iteratively.</li>
  <li>after reading a new item from the huge data, compare it with the smallest number in heap.</li>
  <li>if the number is greater than the smallest number in heap, then pop the top number in heap(also is the smallest one) and push this data into heap.</li>
  <li>otherwise, continue and read a new data.</li>
  <li>finally, dump the \(N\) items in the heap.</li>
</ul>

<p>Since the heap could mantain the <em>heap property</em> by iteself, inserting a new item won’t disorder the heap. As inserting a new item to heap requires \( O(\log N) \) time, the worst case of processing \(n\) data costs \(O(n \log N) \) time.</p>

<p>Following is my C++ solution. The <em>push</em> function of <em>priority_queue</em> will invoke <a href="http://www.cplusplus.com/reference/queue/priority_queue/push/">two functions</a>: one call to push_back on the underlying container and one call to push_heap on the range that includes all the elements of the underlying container.</p>

<pre><code>class Numbers {
	public:
		Numbers(){}
		Numbers(long len){ genNums(len); }
		Numbers(string file){ readNums(file); }

		vector&lt;int&gt;&amp; topN(vector&lt;int&gt;&amp; nums, int N);
		vector&lt;int&gt;&amp; topNbySort(vector&lt;int&gt;&amp; nums, int N);
		vector&lt;int&gt;&amp; genNums(long len);
		vector&lt;int&gt;&amp; readNums(string file);
		void printNums();
		void printTopN(vector&lt;int&gt;&amp; top_num);

	private:
		vector&lt;int&gt; nums;
		vector&lt;int&gt; top_nums;
};

// Find the top N numbers by heap.
vector&lt;int&gt;&amp; Numbers::topN(vector&lt;int&gt;&amp; nums, int N) {
	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; pq; // top element is the minimum
	pq.push(nums.front());
	for(vector&lt;int&gt;::iterator it=nums.begin()+1;it!=nums.end();++it) {
		if(pq.top()&lt;*it) {
			if(pq.size()&lt;N) {
				pq.push(*it);
			} else {
				pq.pop();
				pq.push(*it);
			}
		}
	}
	while(!pq.empty()) {
		top_nums.push_back(pq.top());
		pq.pop();
	}

	return top_nums;
}

// Find the top N numbers using sort.
vector&lt;int&gt;&amp; Numbers::topNbySort(vector&lt;int&gt;&amp; nums, int N) {
	sort(nums.begin(),nums.end()-1);
	auto rit=nums.crbegin();
	for(int i=0;i&lt;N;++i) {
		top_nums.push_back(*rit);
		rit++;
	}
	return top_nums;
}

void Numbers::printTopN(vector&lt;int&gt;&amp; top_num) {
	cout&lt;&lt;"The top "&lt;&lt;top_num.size()&lt;&lt;" numbers are:"&lt;&lt;endl;
	for(auto&amp; x:top_num)
		cout&lt;&lt;x&lt;&lt;" ";
	cout&lt;&lt;endl;
}

vector&lt;int&gt;&amp; Numbers::genNums(long len) {
	for(int i=0;i&lt;len;++i)
		nums.push_back(rand()%len+1);

	return nums;
}

vector&lt;int&gt;&amp; Numbers::readNums(string file) {
	fstream fs(file,std::fstream::in);
	if (fs.is_open()) {
		while(!fs.eof()) {
			int tmp;
			fs&gt;&gt;tmp;
			nums.push_back(tmp);
		}
	} else {
		cerr&lt;&lt;"Failed to open file "&lt;&lt;file&lt;&lt;endl;
	}
	fs.close();
	nums.pop_back(); // delete the last number, because it was read two times.
	return nums;
}

void Numbers::printNums() {
	for(auto&amp; x:nums)
		cout&lt;&lt;x&lt;&lt;" ";
	cout&lt;&lt;endl;
}
</code></pre>

<p>I tested the time costs of sorting and heap when handling 10,000,000 integers respectively. Obviously the heap method is 5 times faster than sort method.</p>

<pre>
macmini:TopNumbers boyang$ time ./top_nums_sort 
The top 10 numbers are:
8507985 9999999 9999997 9999995 9999994 9999992 9999991 9999991 9999990 9999986 

real	0m6.646s
user	0m6.589s
sys	0m0.052s

macmini:TopNumbers boyang$ time ./top_nums_heap 
The top 10 numbers are:
9999986 9999986 9999990 9999991 9999991 9999992 9999994 9999995 9999997 9999999 

real	0m1.182s
user	0m1.130s
sys	0m0.043s
</pre>

	</div>
	</div>
    
	
	<!-- Pagination links -->
	
	<ul class="pager">
	    
	    <li class="previous"><a href="/page2">&larr; Older</a></li>
	    
	
	    
	    <li class="next disabled"><a>Newer &rarr;</a></li>
	    
	</ul>
	
	<!-- content -->
</div>

<div class="col-lg-3">
		<div class="well">
            <h4>Links</h4>
			<a href="https://www.linkedin.com/pub/bo-yang/21/a3/893" target="_blank"> <i class="fa fa-linkedin-square fa-3x"></i> </a> 
			<a href="https://github.com/bo-yang" target="_blank"> <i class="fa fa-github fa-3x"></i> </a> 
			<a href="https://www.facebook.com/bo.yang.52493" target="_blank"> <i class="fa fa-facebook-square fa-3x"></i> </a>
			<a href="http://www.weibo.com/bonnyang" target="_blank"> <i class="fa fa-weibo fa-3x"></i> </a> 
        	<a href="/atom.xml" target="_blank"> <i class="fa fa-rss-square fa-3x"></i> </a>	
        </div>
        <!-- /well -->
        <div class="well">
			<h4>Tags</h4>
				<div class="tag_box">
				
				<!-- site_tags: C/C++,Algorithm,EMC,Fault Diagnosis,Notes,AI,Database,Unix/Linux,Personal,Telecom,Tcl/Tk,Shell,Network,Perl,Industry,Cloud Computing,API,Android,VBA,Virtualization,Browser,Plan 9,Go,Distributed Systems,Tips,Genetic Algorihtm,Mac OS,Statistics,Matlab,Multithreading,Bioinformatics,Computer Vision,Machine Learning,BACI,Jekyll,Architecture,Java -->
				
				<!-- tag_words:  -->

				
  <ul class="nav nav-pills nav-stacked">
  
    
        <li><a href="/tags.html#AI">AI <span class="badge pull-right">7</span></a></li>
    
        <li><a href="/tags.html#API">API <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Algorithm">Algorithm <span class="badge pull-right">25</span></a></li>
    
        <li><a href="/tags.html#Android">Android <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Architecture">Architecture <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#BACI">BACI <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Bioinformatics">Bioinformatics <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Browser">Browser <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#C%2FC%2B%2B">C/C++ <span class="badge pull-right">50</span></a></li>
    
        <li><a href="/tags.html#Cloud+Computing">Cloud Computing <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Computer+Vision">Computer Vision <span class="badge pull-right">4</span></a></li>
    
        <li><a href="/tags.html#Database">Database <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Distributed+Systems">Distributed Systems <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#EMC">EMC <span class="badge pull-right">9</span></a></li>
    
        <li><a href="/tags.html#Fault+Diagnosis">Fault Diagnosis <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Genetic+Algorihtm">Genetic Algorihtm <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Go">Go <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Industry">Industry <span class="badge pull-right">6</span></a></li>
    
        <li><a href="/tags.html#Java">Java <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Jekyll">Jekyll <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Mac+OS">Mac OS <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Machine+Learning">Machine Learning <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Matlab">Matlab <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Multithreading">Multithreading <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Network">Network <span class="badge pull-right">4</span></a></li>
    
        <li><a href="/tags.html#Notes">Notes <span class="badge pull-right">25</span></a></li>
    
        <li><a href="/tags.html#Perl">Perl <span class="badge pull-right">15</span></a></li>
    
        <li><a href="/tags.html#Personal">Personal <span class="badge pull-right">13</span></a></li>
    
        <li><a href="/tags.html#Plan+9">Plan 9 <span class="badge pull-right">9</span></a></li>
    
        <li><a href="/tags.html#Shell">Shell <span class="badge pull-right">15</span></a></li>
    
        <li><a href="/tags.html#Statistics">Statistics <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Tcl%2FTk">Tcl/Tk <span class="badge pull-right">9</span></a></li>
    
        <li><a href="/tags.html#Telecom">Telecom <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Tips">Tips <span class="badge pull-right">4</span></a></li>
    
        <li><a href="/tags.html#Unix%2FLinux">Unix/Linux <span class="badge pull-right">100</span></a></li>
    
        <li><a href="/tags.html#VBA">VBA <span class="badge pull-right">5</span></a></li>
    
        <li><a href="/tags.html#Virtualization">Virtualization <span class="badge pull-right">4</span></a></li>
    
  
  </ul>




				</div>
		</div>
		<!-- /well -->
        <div class="well">
			<h4>Visitors</h4>
				<script type="text/javascript" src="http://je.revolvermaps.com/2/1.js?i=4gy6jc9lpsq&amp;s=220&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script>
	
        </div>
		<!-- /well -->
		<!--
        <div class="well">
            <h3>Recent Posts</h3>
	        <ul>
			
  			<li><span>2014-07-21</span> &raquo; <a href="/2014/07/21/merge-k-sorted-lists">Merge K Sorted Lists</a></li>
			
  			<li><span>2014-07-14</span> &raquo; <a href="/2014/07/14/insertion-sort-list">Insertion Sort List</a></li>
			
  			<li><span>2014-07-13</span> &raquo; <a href="/2014/07/13/linked-list-cycle">Linked List Cycle Problems</a></li>
			
  			<li><span>2014-07-08</span> &raquo; <a href="/2014/07/08/sort-list">Sort List</a></li>
			
  			<li><span>2014-07-07</span> &raquo; <a href="/2014/07/07/subset-sum">Subset Sum Problem</a></li>
			
  			<li><span>2014-07-07</span> &raquo; <a href="/2014/07/07/determine-top-common-ip-addresses">Find Top Source IP Addresses in Distributed Systems</a></li>
			
  			<li><span>2014-07-06</span> &raquo; <a href="/2014/07/06/longest-palindromic-substring">Longest Palindromic Substring</a></li>
			
  			<li><span>2014-07-01</span> &raquo; <a href="/2014/07/01/strstr">The First Occurrence of Needle In Haystack</a></li>
			
  			<li><span>2014-07-01</span> &raquo; <a href="/2014/07/01/longest-consecutive-sequence">Longest Consecutive Sequence</a></li>
			
  			<li><span>2014-06-29</span> &raquo; <a href="/2014/06/29/top-n-numbers">Top N Numbers</a></li>
			
			</ul>
		</div>
		-->
        <!-- /well -->
</div>

	</div>
</div>


    </div>

    <footer>
        <p>&copy; 2007 <span id="now_year"></span> Bo Yang. </p>
        <script type="text/javascript">
          var now_year = new Date().getFullYear();
          if (now_year != 2007) {
              $('#now_year').html('- ' + now_year);
          }
	    </script>
      </footer>
  </div>

  <script type="text/javascript" src="/assets/google-code-prettify/prettify.js"></script>
  <script src="/assets/run_prettify.js"></script>
  <script type="text/javascript">
    $(function() {

      $('a[href^="http"]').each(function () {
        $(this).attr('target', '_blank');
      });

      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
      window.prettyPrint && prettyPrint();

      function traverse($node, len, maxCount) {
        var reachMaxCount = len > maxCount;
        if (reachMaxCount) {
          $node.hide();
        }
        var $contents = $node.contents();
        for (var i = 0; i < $contents.length; ++i) {
          if (reachMaxCount) {
            $contents.eq(i).hide();
            continue;
          }
          if ($contents[i].nodeType == 3) { // TextNode
            var tmp = len;
            var s = $contents[i].nodeValue;
            len += s.length;
            reachMaxCount = len > maxCount;
            if (reachMaxCount && $contents[i].parentNode.nodeName != 'A') {
              $contents[i].nodeValue = s.substring(0, maxCount - tmp);
            }
          }
          else if ($contents[i].nodeType == 1) { // Element
            len = traverse($contents.eq(i), len, maxCount);
          }
        }
        return len;
      }

      $('.post_at_index').each(function() {
        var count = traverse($(this), 0, 400);
        if (count > 400) {
          var thisUrl = $(this).siblings().first().children().attr('href');
          $(this).after('\n<a href="' + thisUrl + '" rel="nofollow" class="btn btn-primary" role="button">' + 'Read More &raquo;</a>');
        }
      });
    });
  </script>

  

</body>
</html>

