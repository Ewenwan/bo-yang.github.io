
<!DOCTYPE HTML>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:wb="http://open.weibo.com/wb">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bo Yang | Bo's Blog</title>
  
  <meta name="author" content="Bo Yang" />
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <!--
  <link href="/assets/themes/clear/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  -->

  <!-- Bootstrap -->
  <link href="/assets/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="/assets/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

  <!-- font-awesome -->
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">

  <!-- Google Prettify -->
  <link href="/assets/google-code-prettify/desert.css" rel="stylesheet" type="text/css" media="all">
  <!-- Google Pretty end -->

  <link href="/assets/style/blog.css" rel="stylesheet">
  
  <script src="/assets/bootstrap/js/jquery-1.10.2.js"></script>
  <script src="/assets/bootstrap/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>

   <!-- navigation bar -->
	<nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
				<a class="navbar-brand" href="/"><b>bo-yang</b></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					<li><a href="/archive.html"><b>Archive</b></a>
					</li>
					<li><a href="/tags.html"><b>Tags</b></a>
                    </li>
                    <li><a href="/about.html"><b>About</b></a>
                    </li>
                    <li><a href="/messages.html"><b>Messages</b></a>
                    </li>
				</ul>
				<ul class="nav navbar-nav pull-right">
		          <li>
		            <form class="navbar-form navbar-search" method="get" action="http://www.google.com/search" target="google_window">
		              <input id="g_search" type="text" class="search-query" placeholder="Search..." name="q" />
		              <input type="submit" name="btnG" style="display:none" id="searchsubmit" value="Search" />
		              <input type="hidden" name="ie" value="UTF-8" />
		              <input type="hidden" name="oe" value="UTF-8" />
		              <input type="hidden" name="hl" value="en-US" />
		              <input type="hidden" name="domains" value="http://bo-yang.github.io/" />
					  <input type="hidden" name="sitesearch" value="http://bo-yang.github.io/" />
					  <button type="submit" class="button button-rounded button-flat-blue">Go</button>
		            </form>
		          </li>
		        </ul>
            </div>
			<!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

  <div class="container">
    <div class="row" id="content-row">
      
<div class="page-header">
	<h1>Bo Yang  <small style="margin-left:20px;"><font face="cursive"><i>Beginner's mind.</i></font></small></h1>
</div>

<div class="container">
    <div class="row" id="content-row">
		<div class="col-md-9">
	<!-- blog entry -->
	
	<div class="post paper">	
    <h2 class="header"><a href="/2014/08/03/string-permutation">String Permutation</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-08-03</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <em>string permutation</em> problem aims to find all the <em>permutations</em> of a string(re-arrangement of characters in this string). A string of length <code>n</code> has <code>n!</code> permutations.</p>

<p>The essence of string permutation is recursively swapping each letter with other letters in this string. Following image shows the permutation of string “ABC”. For each step, fix the left part of the string, and swap two letters in the right part, until there is no letters left in the right part. </p>

<p><img src="http://d2o58evtke57tz.cloudfront.net/wp-content/uploads/NewPermutation.gif" width="678" height="277" class="aligncenter size-full wp-image-118925" />&lt;/img&gt;</p>

<p>Based on above strategy, the following two recusive algorithm could be implemented.</p>

<p>Algorithm 1(Reference: <a href="http://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string/">Write a C program to print all permutations of a given string</a>): </p>

<pre><code>void StrPermute(string&amp; str, vector&lt;string&gt;&amp; vec, int i) {
	if(i==str.length())
		vec.push_back(str);
	else {
		for(int j=i;j&lt;str.size();++j) {
			std::swap(str[i],str[j]);
			StrPermute(str,vec,i+1);
			std::swap(str[i],str[j]);
		}
	} // end if
}
</code></pre>

<p>Algorithm 2(Reference: <a href="http://learnprogramming.machinesentience.com/java_permutations_recursion/">Find all the permutations of a string in Java</a>):</p>

<pre><code>void StrPermute(vector&lt;string&gt;&amp; vec, string prefix, string str) {
	//cout&lt;&lt;"prefix="&lt;&lt;prefix&lt;&lt;", str="&lt;&lt;str&lt;&lt;endl; // TEST ONLY
	int n=str.length();
	if(n==0)
		vec.push_back(prefix);
	else {
		for(int j=0;j&lt;n;++j)
			StrPermute(vec,prefix+str[j],str.substr(0,j)+str.substr(j+1));
	} // end if
}
</code></pre>

<p>The permuted strings are stored as a vector of string. For both algorithms, the time complexities are <code>O(n*n!)</code>.</p>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/28/word-search">Word Search Problem - Non-recursive Solution</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-28</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/word-search/">Word Search</a> states:</p>

<blockquote>
  <p>Given a 2D board and a word, find if the word exists in the grid.</p>

  <p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>

  <p>For example,</p>

  <p>Given board =</p>

  <p>[</p>

  <p>[“ABCE”],</p>

  <p>[“SFCS”],</p>

  <p>[“ADEE”]</p>

  <p>]</p>
</blockquote>

<blockquote>
  <ul>
    <li>word = “ABCCED”, -&gt; returns <code>true</code>,</li>
    <li>word = “SEE”, -&gt; returns <code>true</code>,</li>
    <li>word = “ABCB”, -&gt; returns <code>false</code>.</li>
  </ul>
</blockquote>

<p>The most popular solution to this problem is recursive, such as <a href="http://yucoding.blogspot.com/2013/02/leetcode-question-124-word-search.html">http://yucoding.blogspot.com/2013/02/leetcode-question-124-word-search.html</a>.</p>

<p>However, I tried to solve this problem without recursion. In my implementation, three stacks are used to record the possible coordinates in <code>board</code>, the character position in <code>word</code>(with respect to each candidate cell) and the cells have been accessed to each possible coordinates, repectively. </p>

<p>The first step is finding the possible cells for the first char in <code>word</code>, and push coordinates, position of the char in <code>word</code>(here is 0) and accessed cells(here are matched cells) into stacks. </p>

<p>The second step is exploring all the neighbors of cells in stack, and match each char in <code>word</code> respectively. For a match, push contexts into stack and try to match the next char. For a mismatch, pop the top of stacks and try another candidate. If the search could reach the end of the word, then we successfully find the word. If the stacks turns empty and there are still chars left, that means the seach fails.</p>

<p>Following is my C++ implementation of the non-recursive solution.</p>

<pre><code>class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) {
		if(board.empty())
			return false;

		std::stack&lt;std::pair&lt;int,int&gt;&gt; st_coord; // coordinates of the board
		std::stack&lt;int&gt; st_char; // store characters of the words
		vector&lt;std::pair&lt;int,int&gt; &gt; vec;
		std::stack&lt;vector&lt;std::pair&lt;int,int&gt; &gt; &gt; st_access;
		bool found=false;
        for(int l=0;l&lt;word.length();) {
			if(l==0) { // Find the first character of word in board
				for(int i=0;i&lt;board.size();++i) {
					for(int j=0;j&lt;board[0].size();++j)
						if(board[i][j]==word[l]){
							st_coord.push(std::pair&lt;int,int&gt;(i,j));
							st_char.push(l);
							vec.push_back(std::pair&lt;int,int&gt;(i,j));
							st_access.push(vec);
							vec.pop_back(); // do not affect other candidates
							if(word.size()==1) 
								return true;
						}
				}
				l++;
			} else {
				if(st_coord.empty()) // cannot find the first character
					break;

				// Explore all possible cells to match each character of the word
				while(!st_coord.empty()) {
					int x=st_coord.top().first;
					int y=st_coord.top().second;
					vec=st_access.top();
					l=st_char.top()+1;
					if(l==word.length()) {
						found=true;
						break;
					}
					
					st_coord.pop();
					st_char.pop();
					st_access.pop();

					if(x-1&gt;=0 &amp;&amp; board[x-1][y]==word[l]) {
						vector&lt;std::pair&lt;int,int&gt; &gt;::iterator got=
							std::find(vec.begin(),vec.end(),std::pair&lt;int,int&gt;(x-1,y));
						if(got==vec.end()) {
							st_coord.push(std::pair&lt;int,int&gt;(x-1,y));
							st_char.push(l);
							vec.push_back(std::pair&lt;int,int&gt;(x-1,y));
							st_access.push(vec);
							vec.pop_back(); // do not affect other candidates
						}
					}
					if(x+1&lt;board.size() &amp;&amp; board[x+1][y]==word[l]) {
						vector&lt;std::pair&lt;int,int&gt; &gt;::iterator got=
							std::find(vec.begin(),vec.end(),std::pair&lt;int,int&gt;(x+1,y));
						if(got==vec.end()) {
							st_coord.push(std::pair&lt;int,int&gt;(x+1,y));
							st_char.push(l);
							vec.push_back(std::pair&lt;int,int&gt;(x+1,y));
							st_access.push(vec);
							vec.pop_back(); // do not affect other candidates
						}
					}
					if(y-1&gt;=0 &amp;&amp; board[x][y-1]==word[l]) {
						vector&lt;std::pair&lt;int,int&gt; &gt;::iterator got=
							std::find(vec.begin(),vec.end(),std::pair&lt;int,int&gt;(x,y-1));
						if(got==vec.end()) {
							st_coord.push(std::pair&lt;int,int&gt;(x,y-1));
							st_char.push(l);
							vec.push_back(std::pair&lt;int,int&gt;(x,y-1));
							st_access.push(vec);
							vec.pop_back(); // do not affect other candidates
						}
					}
					if(y+1&lt;board[0].size() &amp;&amp; board[x][y+1]==word[l]) {
						vector&lt;std::pair&lt;int,int&gt; &gt;::iterator got=
							std::find(vec.begin(),vec.end(),std::pair&lt;int,int&gt;(x,y+1));
						if(got==vec.end()) {
							st_coord.push(std::pair&lt;int,int&gt;(x,y+1));
							st_char.push(l);
							vec.push_back(std::pair&lt;int,int&gt;(x,y+1));
							st_access.push(vec);
							vec.pop_back(); // do not affect other candidates
						}
					}
				}
			} // end else
		} // end for l

		return found;
    }
};
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/21/merge-k-sorted-lists">Merge K Sorted Lists</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-21</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<h4 id="contents">Contents</h4>

<ol>
  <li><a href="#naive_method">Naive Method</a></li>
  <li><a href="#divide_conquer">Divide-and-Conquer Algorithm</a></li>
  <li><a href="#heap">Non-Recursive Method</a></li>
</ol>

<p>The <a href="https://oj.leetcode.com/problems/merge-k-sorted-lists/">Merge <code>k</code> Sorted Lists</a> is:</p>

<blockquote>
  <p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>

<p>In this problem, the sorted lists are stored in a vector, i.e. <code>vector&lt;ListNode*&gt;</code>. Assume the longest list contains <code>n</code> elements.</p>

<h3 id="a-namenaivemethodnaive-methoda"><a name="naive_method">Naive Method</a></h3>

<p>The naive method of merging <code>k</code> sorted lists is: iteratively compare the head elements of the <code>k</code> lists, find the smallest node, append this node to the merged list and forward that list by one step. Then repeat above step until all lists reach the end. Obviously, since in every iteration <code>k</code> comparisons are needed, and the longest list has <code>n</code> elements, therefore, the time complexity is \( O(k^{nk}) \) - the worst case is all lists have <code>n</code> elements, so for the total <code>nk</code> elements, totally \( k^{nk} \) comparisons are needed to merge them into one list.</p>

<h3 id="a-namedivideconquerdivide-and-conquer-algorithma"><a name="divide_conquer">Divide-and-Conquer Algorithm</a></h3>

<p>Other than exponential time complexity, a much better method is to use divide-and-conquer. Since merging two sorted lists is easy, we can recursively divide the <code>k</code> lists into two parts until there are no more than two lists. Then we can use a merge method similiar to the merge sort to merge the two lists together.</p>

<p>Assume the longest list contains <code>n</code> elements, the time required for dividing and merging lists is \( T(k)=2T(k/2)+O(nk) \). According to the Master Theorem, the time complexity is \( O(nk \log k) \). The space complexity of this algorithm is \( O(1) \).</p>

<p>Following is my C++ implementation of the divide-conquer method.</p>

<pre><code>class Solution {
public:
    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {
		if(lists.size()==0)
            return NULL;
        if(lists.size()==1)
            return lists[0];

		return divideConquerLists(lists,0,lists.size()-1);
    }

	ListNode* divideConquerLists(vector&lt;ListNode *&gt; &amp;lists, int start, int end) {
		if(start+1&lt;end) {
			int mid=(start+end)/2;
			ListNode* head1=divideConquerLists(lists,start,mid);
			ListNode* head2=divideConquerLists(lists,mid+1,end);
			return mergeTwoLists(head1,head2);
		} else if(start+1==end) {
			return mergeTwoLists(lists[start],lists[end]);
		} else if(start==end) {
			return lists[start];
		}
	}

	ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
		if(head1==NULL)
			return head2;
		if(head2==NULL)
			return head1;
	
		ListNode* pre_head=new ListNode(-1);
		ListNode* pre=pre_head;
		ListNode* node1=head1;
		ListNode* node2=head2;
		while(node1!=NULL &amp;&amp; node2!=NULL) {
			if(node1-&gt;val &lt; node2-&gt;val) {
				pre-&gt;next=node1;
				node1=node1-&gt;next;
			} else {
				pre-&gt;next=node2;
				node2=node2-&gt;next;
			}
			pre=pre-&gt;next;
		}
		while(node1!=NULL) {
			pre-&gt;next=node1;
			node1=node1-&gt;next;
			pre=pre-&gt;next;
		}
		while(node2!=NULL) {
			pre-&gt;next=node2;
			node2=node2-&gt;next;
			pre=pre-&gt;next;
		}
		pre-&gt;next=NULL;

		ListNode* head=pre_head-&gt;next;
		delete pre_head;

		return head;
	}
};
</code></pre>

<h3 id="a-nameheapnon-recursive-methoda"><a name="heap">Non-Recursive Method</a></h3>

<p>In addition to the recursive divide-conquer method, there is also a non-recursive method. We can use a maximum <code>k</code>-element heap(in C++, <code>priority_queue</code>) to merge the <code>k</code> lists. The strategy is:</p>

<ol>
  <li>Create a heap to store <code>ListNode*</code>, which should sort list nodes in the ascending order or node values.</li>
  <li>Insert the first node(head) of each list into the heap, so that we store all the <code>k</code> entries in the heap.</li>
  <li>Get the top element in heap and add in to the merged list.</li>
  <li>If the top element of heap is the last node in a list, pop it and go to step 3.</li>
  <li>If the top element of heap has followers, pop it and push its following node into heap. </li>
  <li>Go to step 3 until the heap is empty.</li>
</ol>

<p>To create a heap meet step’1 requirement, we need to create a structure/class that overloads the operator <code>()</code>, so that we can compare two list nodes based on their values. Such structure/class is required by the <code>priority_queue</code> template. Instead of a struct, I would rather use a lambda function to do so. Unfortunately, lambda function still cannot be used as the comparison object in <code>priority_queue</code>.</p>

<p>For a <code>k</code>-element <code>priority_queue</code>, an insertion requires \( O(\log k) \) time. Since we need to do such insertion for at most \(nk\) times, therefore the time complexity for this method is also \( O(nk \log k) \). Obviously, the space complexity of this algorithm is \( O(k) \).</p>

<pre><code>class Solution {
public:
	// comparison structure, required by priority_queue template
	struct greaterListNode{ 
		bool operator() (ListNode* x, ListNode* y) {return x-&gt;val &gt; y-&gt;val;}
	};

    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {
		if(lists.size()==0)
			return NULL;
		if(lists.size()==1)
			return lists[0];

		ListNode* pre_head=new ListNode(-1);
		ListNode* pre=pre_head;
		std::priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, greaterListNode&gt; pq;

		// Insert entries of every list into heap
		for(auto&amp; lst:lists)
			if(lst!=NULL)
				pq.push(lst);

		// Recursively parse every element in lists
		while(!pq.empty()) {
			pre-&gt;next=pq.top();
			pre=pre-&gt;next;
			pq.pop();

			if(pre!=NULL &amp;&amp; pre-&gt;next!=NULL)
				pq.push(pre-&gt;next);
		}

		ListNode* head=pre_head-&gt;next;
		delete pre_head;
		return head;
    }
};
</code></pre>

<h3 id="references">References:</h3>

<ol>
  <li><a href="http://blog.csdn.net/linhuanmars/article/details/19899259">Merge k Sorted Lists – LeetCode</a></li>
  <li><a href="http://www.cplusplus.com/reference/queue/priority_queue/">std::priority_queue</a></li>
  <li><a href="http://www.cplusplus.com/reference/functional/greater/">std::greater</a></li>
</ol>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/14/insertion-sort-list">Insertion Sort List</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-14</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/insertion-sort-list/">Insertion Sort List problem</a> is:</p>

<blockquote>
  <p>Sort a linked list using insertion sort.</p>
</blockquote>

<p>There is a very simple insertion sort method for arrays in Wikipedia.</p>

<pre><code>for i ← 1 to length(A)
    j ← i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ← j - 1
</code></pre>

<p>The core of this algorithm is to find the position where to insert an smaller element. Compared to array, the list nodes cannot access nodes before them - they only know the nodes behind them. Therefore, instead of looking for insert positions decreasingly from current position down to the beginning, we can search the position from the head instead.</p>

<p>Following is my C++ implementation. Swapping two nodes is a little tricky, because you need to take care of four links.</p>

<pre><code>struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
 
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        if(head==NULL||head-&gt;next==NULL)
			return head;

		ListNode* pre_head=new ListNode(-1); // to manipulate the head
		pre_head-&gt;next=head;
		ListNode* cur=head;
		while(cur-&gt;next!=NULL) {
			if(cur-&gt;val &gt; cur-&gt;next-&gt;val) {
				ListNode* node=pre_head;

				// find position to insert
				while(node-&gt;next-&gt;val &lt; cur-&gt;next-&gt;val)
					node=node-&gt;next;

				// swap nodes
				ListNode* tmp1=node-&gt;next;
				ListNode* tmp2=cur-&gt;next-&gt;next;
				node-&gt;next=cur-&gt;next;
				cur-&gt;next-&gt;next=tmp1;
				cur-&gt;next=tmp2;
			} else {
				cur=cur-&gt;next;
			}
		}
		
		head=pre_head-&gt;next;
		delete pre_head;

		return head;
    }
};
</code></pre>

<p>In addition to above insertion sort, which moves smaller elements forward, we also can move the larger elments backward. The following code is more like bubble sort.</p>

<pre><code>ListNode *insertionSortList(ListNode *head) {
    if(head==NULL||head-&gt;next==NULL)
		return head;

	// find the length of the list
	int len=0;
	ListNode* node=head;
	while(node!=NULL) {
		node=node-&gt;next;
		len++;
	}

	// iteratively insert the largest number to the end
	for(int i=len-1;i&gt;=0;i--) {
		int j=0;
		node=head;
		ListNode* prev=NULL; // previous of node
		while(j&lt;i &amp;&amp; node!=NULL &amp;&amp; node-&gt;next!=NULL) {
			if(node-&gt;val &gt; node-&gt;next-&gt;val) {
				// swap nodes
				ListNode* tmp=node-&gt;next;
				node-&gt;next=node-&gt;next-&gt;next;
				tmp-&gt;next=node;
				if(j==0||prev==NULL) {
					head=tmp;
				} else {
					prev-&gt;next=tmp;
				}
				prev=tmp;
			} else {
				prev=node;
				node=node-&gt;next;
			}
			j++;
		}
	} // end for

	return head;
}
</code></pre>


	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/13/linked-list-cycle">Linked List Cycle Problems</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-13</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/linked-list-cycle/">Linked List Cycle problem</a> is:</p>

<blockquote>
  <p>Given a linked list, determine if it has a cycle in it. Can you solve it without using extra space?</p>
</blockquote>

<p>A <a href="https://oj.leetcode.com/problems/linked-list-cycle-ii/">follow up problem</a> is:</p>

<blockquote>
  <p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.Can you solve it without using extra space? </p>
</blockquote>

<p>The first problem can be solved by the <strong><a href="http://www.geeksforgeeks.org/write-a-c-function-to-detect-loop-in-a-linked-list/">Floyd’s Cycle-Finding Algorithm</a></strong>:</p>

<blockquote>
  <p>Traverse linked list using two pointers: move one pointer by <em>one</em> and other pointer by <em>two</em>.  If these pointers meet at some node then there is a loop.  If pointers do not meet then linked list doesn’t have loop.</p>
</blockquote>

<p>As for the second problem, it is also based on the <strong>Floyd’s Cycle-Finding Algorithm</strong>. However, after detecting loop, we need to find the starting point of the cycle. <strong>The most convinient way is to use two pointers, one points to the head node, and the other points to the node that pointers meet when detecting loop. Then move both the two pointers by one respectively in each iteration, until they meet. The node they meet is the starting point of the cycle.</strong></p>

<p>Here is the detailed explanation of above trick(reference: <a href="http://www.cnblogs.com/TenosDoIt/p/3416702.html">http://www.cnblogs.com/TenosDoIt/p/3416702.html</a>). </p>

<ol>
  <li>Assume the length(number of nodes, the same below) of the list is <code>l</code>, the distance(number of nodes, the same below) between <code>head</code> and the starting point of cycle is <code>a</code>, the distance between the cycle-starting point and the point where the slow/fast pointers meet is <code>b</code>, and the length of the cycle is <code>r</code>.</li>
  <li>Assume when the fast/slow pointers meet, the slow pointer has accessed <code>s</code> nodes. Then the fast pointer has moved <code>2s</code>, and <code>s=a+b</code>.</li>
  <li>Since the nodes accessed by the fast pointer also calculated as <code>kr+s</code>, where <code>k</code> is the number of cycles and \( k \ge 1 \). We have <code>2s=kr+s</code>, i.e. <code>s=kr</code>.</li>
  <li>Since <code>s=a+b</code> and <code>s=kr</code>, we have <code>a+b=kr=(k-1)r+r</code>. Since <code>r=l-a</code>, we have <code>a+b=(k-1)+l-a</code>, i.e. <code>a=(k-1)+l-a-b</code>. Notice that <code>l-a-b</code> is the distance from the point where slow/fast pointers meet to the starting point of cycle(note: we only can go through the cycle of the linked list in one direction).</li>
  <li>Since <code>a</code> is the distance between <code>head</code> node and the starting point of cycle, <code>a=(k-1)+l-a-b</code> means that the distance between <code>head</code> node and the starting point of cycle(<code>a</code>) <em>equals</em> to the distance from the point where slow/fast pointers meet to the starting point of cycle(<code>l-a-b</code>) plus several loops of the cycle.</li>
  <li>Therefore, when we use two pointers to find the starting point of cycle, one pointer moves to the start point from the head of the list, while the other pointer winds aroung the cycle at the same pace. When the two pointers meet, one pointer must have moved <code>a</code> and the other moved <code>(k-1)+l-a-b</code>.</li>
</ol>

<p>Following is my C++ implmentation.</p>

<pre><code>class Solution {
public:
	ListNode *detectCycle(ListNode *head) {
		if(head==NULL || head-&gt;next==NULL)
			return NULL;

		ListNode* first=head;
		ListNode* second=head;
        while(first!=NULL &amp;&amp; second!=NULL &amp;&amp; second-&gt;next!=NULL) {
			first=first-&gt;next;
			second=second-&gt;next-&gt;next;

			if(first==second)
				break;
		}

		if(first==second) {
			// Continue walking X steps
			first = head;
			while(first!=second)
			{
	            first = first-&gt;next;
	            second = second-&gt;next;
	        }
	
			return second;
		} else {
			return NULL;
		}
    }

	// Create list with cycle using given vector of integers.
	// 	lb - the beginning index(in vec) of the cycle.
	ListNode* createList(vector&lt;int&gt;&amp; vec, int lb) {
		head=new ListNode(vec[0]);
		ListNode* node=head;
		ListNode* begin=NULL;
		for(int i=1;i&lt;vec.size();++i) {
			node-&gt;next=new ListNode(vec[i]);
			node=node-&gt;next;
			if(i==lb)
				begin=node;
		}
		if(lb&gt;0 &amp;&amp; lb&lt;vec.size())
			node-&gt;next=begin;
		else if(lb&gt;=vec.size()) // index out of upper bound, set to NULL
			node-&gt;next=NULL;
		else
			node-&gt;next=head; // index out of lower bound, linked to the head

		return head;
	}

	void printList(ListNode *head) {
		ListNode* node=head;
		while(node!=NULL) {
			cout&lt;&lt;node-&gt;val&lt;&lt;" ";
			node=node-&gt;next;
		}
		cout&lt;&lt;endl;
	}

	Solution() {head=NULL;}

	~Solution() {
		ListNode* node=head;
		while(head!=NULL){
			head=head-&gt;next;
			delete node;
			node=head;
		}
	}

private:
	ListNode* head;

};
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/08/sort-list">Sort List</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-08</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/sort-list/">The Sort List problem</a> is:</p>

<blockquote>
  <p>Sort a linked list in \( O(n log n) \) time using constant space complexity.</p>
</blockquote>

<p>The solution to this problem is modifying the array/vector based merge sort and make it work for lists. The key is finding the middle node of each list to be sorted. This can be achieved by two pointers: one points to the head of list(<code>mid</code>), and the other point to the next node of head(<code>end</code>). Then iteratively go through elements in the list - the <code>mid</code> pointer increase one position in each iteration, while the <code>end</code> pointer increased two positions. Thus when <code>end</code> pointer reached the end of the list, the <code>mid</code> pointer arrives at the middle of the list.</p>

<p>Following is my C++ implementation, which contains methods of creating list, printing list, sorting list and deleting allocated memory.</p>

<pre><code>struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};
 
class Solution {
public:
    ListNode *sortList(ListNode *head) {
	   //cout&lt;&lt;"sorting list: "; // TEST ONLY
	   //printList(head); // TEST ONLY

       if(head==NULL || head-&gt;next==NULL) 
		   return head;

	   // Find the middle node of the list
	   ListNode* mid=head;
	   ListNode* end=head-&gt;next;
	   while(end!=NULL &amp;&amp; end-&gt;next!=NULL) {
		   mid=mid-&gt;next;
		   end=end-&gt;next-&gt;next;
	   }

	   ListNode* head_right=mid-&gt;next;
	   mid-&gt;next=NULL;
	   ListNode* head_left=sortList(head);
	   head_right=sortList(head_right);
	   head=mergeList(head_left,head_right);

	   //cout&lt;&lt;"merged lists: "; // TEST ONLY
	   //printList(head); // TEST ONLY

	   return head;
    }

	ListNode* mergeList(ListNode *head_left, ListNode *head_right) {
		if(head_left==NULL &amp;&amp; head_right==NULL)
			return NULL;

		// Determine the head
		ListNode* head=NULL;
		if(head_left==NULL || head_left-&gt;val &gt; head_right-&gt;val) {
			head=head_right; 
			head_right=head_right-&gt;next;
		} else {
			head=head_left;
			head_left=head_left-&gt;next;
		}

		// Merge lists in ascending order
		ListNode* node=head;
		while(head_left!=NULL &amp;&amp; head_right!=NULL) {
			if(head_left-&gt;val &lt; head_right-&gt;val) {
				node-&gt;next=head_left;
				head_left=head_left-&gt;next;
			} else {
				node-&gt;next=head_right;
				head_right=head_right-&gt;next;
			}
			node=node-&gt;next;
		}
		while(head_left!=NULL) {
			node-&gt;next=head_left;
			node=node-&gt;next;
			head_left=head_left-&gt;next;
		}
		while(head_right!=NULL) {
			node-&gt;next=head_right;
			node=node-&gt;next;
			head_right=head_right-&gt;next;
		}

		return head;
	}

	// Create list using given vector of integers
	ListNode* createList(vector&lt;int&gt;&amp; vec) {
		head=new ListNode(vec[0]);
		ListNode* node=head;
		for(int i=1;i&lt;vec.size();++i) {
			node-&gt;next=new ListNode(vec[i]);
			node=node-&gt;next;
		}

		return head;
	}

	void printList(ListNode *head) {
		ListNode* node=head;
		while(node!=NULL) {
			cout&lt;&lt;node-&gt;val&lt;&lt;" ";
			node=node-&gt;next;
		}
		cout&lt;&lt;endl;
	}

	Solution() {head=NULL;}

	~Solution() {
		ListNode* node=head;
		while(head!=NULL){
			head=head-&gt;next;
			delete node;
			node=head;
		}
	}

private:
	ListNode* head;
};
</code></pre>

<p>Following code can be used for testing the above solution:</p>

<pre><code>int main() {
	vector&lt;int&gt; vec={3,6,2,-1,4,7,4,11,9,20,8,-3,0};
	Solution sol;
	ListNode* head=sol.createList(vec);
	cout&lt;&lt;"Before sorting:"&lt;&lt;endl;
	sol.printList(head);
	
	head=sol.sortList(head);
	cout&lt;&lt;"After sorting:"&lt;&lt;endl;
	sol.printList(head);
}
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/07/subset-sum">Subset Sum Problem</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-07</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/3sum/">The 3Sum problem</a> is:</p>

<blockquote>
  <p>Given an array <code>S</code> of n integers, are there elements <code>a, b, c</code> in <code>S</code> such that <code>a + b + c = 0</code>? Find all unique triplets in the array which gives the sum of zero.</p>

  <p>Note:</p>

  <ul>
    <li>Elements in a triplet <code>(a,b,c)</code> must be in non-descending order. (ie, <code>a ≤ b ≤ c</code>)</li>
    <li>The solution set must not contain duplicate triplets.</li>
  </ul>
</blockquote>

<p>Inspired by the <a href="http://en.wikipedia.org/wiki/3SUM">Wikipedia solution</a>, I implemented following solution. The first step is sorting the array <code>S</code> in ascending order, so that we can guarantee the front elements in the array are not less than the elemts at the end of the array. Then for every number in array, we can use the two variables to go through the whole array to find the triplets summed to 0. </p>

<p>In order to guarantee there are no duplicate triplets, a hash table is used to record the triplets that have been found. Before inserting the newly found triplet into the solution matrix(<code>vector&lt;vector&lt;int&gt; &gt;</code>), try to look for the triplet in the hash table first. Since C++ doesn’t support <code>vector&lt;int&gt;</code> keys, I formulate string keys using the integer triplets in the following code.</p>

<pre><code>class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; threeSum(vector&lt;int&gt; &amp;num) {
		// Sort the vector
		std::sort(num.begin(), num.end());
		
		// Find triplets
		unordered_map&lt;string,bool&gt; map; // store found triplets
		char* buf=new char[100];
		for(int i=0;i&lt;num.size();++i) {
			vector&lt;int&gt; triplet;
			int hi=num.size()-1;
			int lo=0;
			while(hi&gt;i &amp;&amp; lo&lt;i) {
				if(num[i]+num[hi]+num[lo]==0) { // found a triplet
					sprintf(buf,"%d%d%d",num[i],num[hi],num[lo]);
					string str(buf);
					unordered_map&lt;string,bool&gt;::const_iterator got=map.find(str);
					if(got==map.end()) { // a brand new triplet
						triplet.push_back(num[lo]);
						triplet.push_back(num[i]);
						triplet.push_back(num[hi]);
						map[str]=true;
						sol.push_back(triplet);
					}
					triplet.clear();
					hi--;lo++;
				} else if(num[i]+num[hi]+num[lo]&gt;0) {
					hi--;
				} else { // &lt;0
					lo++;
				}
			}
		}
		delete [] buf;

		return sol;
    }
	
private:
	vector&lt;vector&lt;int&gt; &gt; sol;
};
</code></pre>


	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/07/determine-top-common-ip-addresses">Find Top Source IP Addresses in Distributed Systems</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-07</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Distributed Systems-ref" rel="nofollow">Distributed Systems</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Perl-ref" rel="nofollow">Perl</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Network-ref" rel="nofollow">Network</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The problem is:</p>

<blockquote>
  <p>Determines the top 10 most common source IP addresses, and their hit rates, for a fleet of 1000 web servers within the last hour.</p>

  <p>The following assumptions may be used…</p>

  <ul>
    <li>web servers are locally writing access logs in the <a href="http://httpd.apache.org/docs/current/logs.html#combined">Apache Combined Log Format</a>.</li>
    <li>web servers are accessible by <code>ssh</code>.</li>
  </ul>
</blockquote>

<p>My solution is:</p>

<ol>
  <li>For each server in the fleet, copy the <code>/var/log/httpd/access_log</code> to local directory by <code>ssh</code>.</li>
  <li>Given a access_log, for each line in the log, extract the IP address, time/time zone and status code. </li>
  <li>For lines written in the past hour, count the occurrences of each IP address(number of requests) and numbers of sucessful operations(status code 1xx,2xx and 3xx in my implementation).</li>
  <li>After counting logs of all servers, sort the IP addresses by their occurrences.</li>
  <li>For the top 10 IP addresses, calculate their hit rates using equation:
 <code>hit rate = (# of successful operations) / (# of all requests)</code></li>
</ol>

<p>Assumptions are:</p>

<ol>
  <li>The names of servers in the fleet are stored in a file, such as ‘fleet_servers’. The servers can be geographically distributed in different cities/countries.</li>
  <li>This script will be executed in a directory that can be read &amp; written by the user. </li>
  <li>The report of the top 10 most common IPs and hit rates will be stored in current directory.</li>
  <li>The SSH keys to remote servers have been generated and synced, so that there is no need to manually enter the passwords. </li>
  <li>Following Perl modules should be installed:
    <ul>
      <li><code>DateTime</code> - used to determine if the logs are older than 1 hour.</li>
      <li><code>Parallel::ForkManager</code> - check multiple logs in concurrently.</li>
    </ul>
  </li>
</ol>

<p>Following is my Perl implementation. For more information and the source file, please refer to <a href="https://github.com/bo-yang/CommonSourceIPs">https://github.com/bo-yang/CommonSourceIPs</a>.</p>

<pre><code>use strict;
use warnings;
use POSIX qw(strftime);
use DateTime;
use Parallel::ForkManager;
use Getopt::Long;
use FindBin qw($Bin);
use Cwd 'abs_path';

my $ldt=DateTime-&gt;now(); # Get UTC date time
my $input='fleet_servers'; # default file to store server list
my $output="report_".strftime("%Y%d%m_%H%M%S",localtime()); # default file t ostore report
my $login=`whoami`;
my $access_log='/var/log/httpd/access_log'; # the default location of the access log
my $time_range=1; # 1 hour by default
my $num_ips=10;	# number of the most common source IP addresses
my $num_process=30; # Max number of processes for parallel processing

GetOptions(
	'input|i=s'  =&gt; \$input,
	'output|o=s' =&gt; \$output,
	'login|l=s'  =&gt; \$login,
	'alog|a=s'   =&gt; \$access_log,
	'trange|t=i' =&gt; \$time_range,
	'num_ip|n=i' =&gt; \$num_ips,
	'process|p=i'=&gt; \$num_process,
	'help|?'	 =&gt; \&amp;ShowUsage
   ) or ShowUsage();


die("ERROR: no input reads specied!\n") if (!$input);

# Handle signals
my $CleanupDone   = 0;
$SIG{'ABRT'} = 'doCleanup';
$SIG{'HUP'}  = 'doCleanup';
$SIG{'INT'}  = 'doCleanup';
$SIG{'QUIT'} = 'doCleanup';

open IN, "&lt;$input" or die("ERROR: cannot open file $input!");

# Iteratively access each server. Assume that each line of the input file is 
# a server name or IP address.
my $clients={};
my $pm = new Parallel::ForkManager($num_process);
while (my $server = &lt;IN&gt;) {
	$pm-&gt;start and next; # do the fork

	chomp $server;
	my $tmplog=".${server}.access_log.tmp";
	`ssh ${login}@${server} "cat ${access_log}" &gt; $tmplog`;

	open LOG, "&lt;$tmplog" or die("ERROR: cannot open file $tmplog!");
	# Parse the access_log of this server
	while (my $line = &lt;LOG&gt;) {
		if($line =~ /^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/) {
			my $ip=$1;
			my ($rdt, $stat_code)=($line =~ m/\[(.*)\].*" (\d{3})/);
	
			# Calculate time differece between local and remote servers(in seconds)
			my $time_diff=CompareTime($ldt,$rdt);
			# Skip messages older than specified time range
			next if($time_diff &gt; $time_range*3600);
	
			# Count requests and successful oprations
			if(not $clients-&gt;{$ip}){
				$clients-&gt;{$ip}-&gt;{'request'}=1;
				$clients-&gt;{$ip}-&gt;{'success'}=0;
			} else {
				$clients-&gt;{$ip}-&gt;{'request'}++;
			}
			# Only status code that begins with 1, 2 or 3 will be counted
			$clients-&gt;{$ip}-&gt;{'success'}++ if($stat_code =~ /[1-3]\d{2}/);
		} else {
			warn "No IP address found in ${tmplog}.";
		}
	}
	close LOG;
	unlink $tmplog; # remove temporary files

	$pm-&gt;finish;
}
$pm-&gt;wait_all_children; # wait for forked-processes

close IN;

# Find the most common IP addresses and calculate their hit rates
open OUT, "&gt;$output" or die("ERROR: cannot write file $output!");
print OUT "IP Address \t Hit Rate \t # Req \t # Succ\n";
print STDOUT "IP Address \t Hit Rate \t # Req \t # Succ\n";
my $cnt=0;
# Sort source IP addresses in descending order of requests
foreach my $ip (sort {$clients-&gt;{$b}-&gt;{'request'} &lt;=&gt; $clients-&gt;{$a}-&gt;{'request'}} keys %{$clients}) {
	# Calculate hit rate
	$clients-&gt;{$ip}-&gt;{'hit rate'}=$clients-&gt;{$ip}-&gt;{'success'}/$clients-&gt;{$ip}-&gt;{'request'};
	my $hit_rate=sprintf("%.4f",$clients-&gt;{$ip}-&gt;{'hit rate'});
	print OUT "$ip \t $hit_rate \t $clients-&gt;{$ip}-&gt;{'request'} \t $clients-&gt;{$ip}-&gt;{'success'}\n";
	print STDOUT "$ip \t $hit_rate \t $clients-&gt;{$ip}-&gt;{'request'} \t $clients-&gt;{$ip}-&gt;{'success'}\n";

	$cnt++;
	last if($cnt&gt;=$num_ips); # break out
}

close OUT;


#
# Compare two time and return the differences in seconds.
# 
# Inputs: 
# 	local time(array), remote time(string)
# Output: 
# 	time difference(in seconds)
#
sub CompareTime {
	my $ldt=$_[0]; # local time, array
	my $remote_dt=$_[1]; # remote time, string
	
	my %month_map = (
		'Jan' =&gt; 1, 'Feb' =&gt; 2, 'Mar' =&gt; 3,
		'Apr' =&gt; 4, 'May' =&gt; 5, 'Jun' =&gt; 6,
		'Jul' =&gt; 7, 'Aug' =&gt; 8, 'Sep' =&gt; 9,
		'Oct' =&gt; 10,'Sep' =&gt; 11,'Dec' =&gt; 12
	);

	my ($rday,$rmonth,$ryear,$rhour,$rmin,$rsec,$rtz)=($remote_dt =~ m/(\d+)\/(\S+)\/(\d+):(\d+):(\d+):(\d+) ([+-]\d+)/);
	my $rdt = DateTime-&gt;new(
		year	=&gt; $ryear,
		month	=&gt; $month_map{$rmonth},
		day		=&gt; $rday,
		hour	=&gt; $rhour,
		minute	=&gt; $rmin,
		second	=&gt; $rsec,
		time_zone =&gt; $ldt-&gt;time_zone,
	);

	# Convert the remote time into UTC time zone.
	my $ltz='+0000';
	if($ltz ne $rtz) {
		my $abs_rtz=$rtz;
		if($abs_rtz =~ m/[+-].*/) {
			$abs_rtz=substr $abs_rtz, 1; # remove the leading +/-
		}
		# The ISO 8601 offset from UTC in timezone linke +0700 (1 minute=1, 1 hour=100)
		my $tz_diff=$abs_rtz/100*3600; # time zone diff in seconds
		my $dur = DateTime::Duration-&gt;new(
			years       =&gt; 0,
	      	months      =&gt; 0,
	      	weeks       =&gt; 0,
	      	days        =&gt; 0,
	      	hours       =&gt; 0,
	      	minutes     =&gt; 0,
	      	seconds     =&gt; $tz_diff,
	      	nanoseconds =&gt; 0
		);
		# Add/subtract time zone influence
		if($rtz =~ /\-\d+/) {
			$rdt-&gt;add_duration($dur);
		} else {
			$rdt-&gt;subtract_duration($dur);
		}
	}
	
	# Calculate the absolute time differences in seconds
	my $time_diff=$ldt-&gt;subtract_datetime_absolute($rdt);
	return $time_diff-&gt;in_units('seconds');
}

#
# Show usgage
# 
sub ShowUsage {
	my $proc=`basename $0`;
	chomp($proc);

	print STDOUT "Usage: $proc [-i server_list] [-o report] [-l login] [-a access_log] [-t time_range] [-n ip_num] [-p process_num]\n";
	print STDOUT "where:\n";
	print STDOUT "  server_list\t - list of servers in the pool, optional\n";
	print STDOUT "  report\t - report file, optional \n";
	print STDOUT "  login\t\t - login to admin servers, optional\n";
	print STDOUT "  access_log\t - path of Apache access_log, optional\n";
	print STDOUT "  time_range\t - range of time to be analysed(unit: hour), optional\n";
	print STDOUT "  ip_num\t - number of the top source IPs, optional\n";
	print STDOUT "  process_num\t - number of concurrent processes, optional\n";
	
	exit;
}

#
# Clean up before exit
#
sub doCleanup {
	if($CleanupDone == 1) {
		exit;
	}

	`rm .*.access_log.tmp`; # remove temp files
	$CleanupDone = 1;
	exit 0;
} ## end sub doCleanup
</code></pre>

	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/06/longest-palindromic-substring">Longest Palindromic Substring</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-06</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p>The <a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring problem</a> is:</p>

<blockquote>
  <p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring. </p>
</blockquote>

<p>To solve this problem, first investigate following examples:</p>

<ul>
  <li><code>abcdefedchz</code>: the longest palindrome is <code>cdefedc</code>, the left and right parts are symmetric to letter <code>f</code>.</li>
  <li><code>acbbcae</code>: the longest palindrome <code>acbbca</code>, which is symmetric to the (virtual) postion between <code>bb</code>.</li>
  <li><code>a</code>: the longest palindrome is the letter <code>a</code>.</li>
</ul>

<p>Based on above investigations, we could summarize the solution as: </p>

<ol>
  <li>For every letter in the string, find the longest repetitive characters to current letter, record the <code>start</code> and <code>end</code> position;</li>
  <li>Minus <code>start</code> position by one and see if <code>s[start]</code> is still identical to <code>s[end]</code>.</li>
  <li>If yes, iteratively compare <code>s[start--]</code> and <code>s[end--]</code> until they are not equal.</li>
  <li>The possible longest palindrome for current letter is <code>end-start-1</code>.</li>
</ol>

<p>Following is my C++ implementation. This algorithm could be enhanced by not checking every letters, however, the time complexity will still be \( O(N^2) \). A better method is <a href="http://en.wikipedia.org/wiki/Longest_palindromic_substring">Manacher’s Algorithm</a>, which has  \( O(N) \) time complexity.</p>

<pre><code>class Solution {
public:
    string longestPalindrome(string s) {
		if(s.empty())
			return "";

        int pd_start=0; // the start position of the palindrome
		int pd_len=0; // the length of the palindrome
		for(int i=0;i&lt;s.length();++i) {
			int start=i;
			int end=i;
			while(end&lt;s.length() &amp;&amp; s[start]==s[end])
				end++;

			start--;
			while(start&gt;=0 &amp;&amp; end&lt;s.length() &amp;&amp; s[start]==s[end]) {
				start--;
				end++;
			}
			
			if(pd_len&lt;end-start-1) {
				pd_len=end-start-1;
				pd_start=start+1;	
			}
		}

		return s.substr(pd_start,pd_len);		
    }
};
</code></pre>


	</div>
	</div>
    
	<div class="post paper">	
    <h2 class="header"><a href="/2014/07/01/strstr">The First Occurrence of Needle In Haystack</a></h2>
    <p>
    	<span class="glyphicon glyphicon-time"></span> Posted by <strong>Bo Yang</strong> at <strong>2014-07-01</strong> with tags <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#Algorithm-ref" rel="nofollow">Algorithm</a>, <span class="glyphicon glyphicon-tag"></span><a href="/tags.html#C/C++-ref" rel="nofollow">C/C++</a>
	</p>
	<hr>
    
    <div class="post_at_index thepost">
    	<p><a href="https://oj.leetcode.com/problems/implement-strstr/">The problem</a> is:</p>

<blockquote>
  <p>Implement strStr().</p>

  <p>Returns a pointer to the first occurrence of needle in haystack, or null if needle is not part of haystack.</p>
</blockquote>

<p>A naive method: (1) find the the first letter of <code>needle</code> in <code>haystack</code>, (2)comparing other consecutive characters of needle and haystack, (3) if all letters in <code>needle</code> can be found in <code>haystack</code> consecutively, then return the position in <code>haystack</code>.</p>

<pre><code>class Solution {
public:
    char *strStr(char *haystack, char *needle) {
		if(haystack==NULL || needle==NULL)
			return NULL;

		if(needle[0]=='\0')
			return haystack;

		// Find the first character of needle in haystack
		int hay_len=strlen(haystack);
		int need_len=strlen(needle);
		int pos=0;
		bool found=false;
		while(hay_len-pos&gt;=need_len &amp;&amp; haystack[pos]!='\0') {
			if(haystack[pos] == needle[0]){
				int th=pos+1;
				int tn=1;
				while(haystack[th] == needle[tn]) {
					if(needle[tn]=='\0')
						break;
					th++;
					tn++;
				}
				if(tn == need_len) {
					found=true;
					break;
				}
			}
			pos++;
		}

		if(found)
			return haystack+pos;
		else
			return NULL;
    }
};
</code></pre>

<p>A better solution is to use the famous KMP algorithm(<a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/">http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/</a>).</p>

<pre><code>class Solution {
public:
    char *strStr(char *haystack, char *needle) {
		if(haystack==NULL || needle==NULL)
	 		return NULL;
	 	if(needle[0]=='\0')
	 		return haystack;

		int n=strlen(haystack);
		int m=strlen(needle);
		vector&lt;int&gt; pi(m); // the longest proper prefix which is also suffix
		computePrefix(needle,pi);
		//printPrefix(pi); // TEST ONLY

		int q=0; // index for needle
		int i=0; // index for haystack
		while(i&lt;n) {
			//cout&lt;&lt;"needle["&lt;&lt;q&lt;&lt;"]="&lt;&lt;needle[q]&lt;&lt;", haystack["&lt;&lt;i&lt;&lt;"]="&lt;&lt;haystack[i]&lt;&lt;endl; // TEST ONLY
			if(needle[q]==haystack[i]) {
				q++;
				i++;
			}
			if(q==m) {
				//cout&lt;&lt;"Pattern occurs with shift "&lt;&lt;i-m&lt;&lt;endl; // TEST ONLY
				return haystack+i-m;
			} else if(needle[q]!=haystack[i]) {
				if(q!=0)
					q=pi[q-1];
				else
					i++;
			}
		}
		return NULL;
	}

	// Calculate the longest proper prefix which is also suffix.
	// Examples:
	// 	For the pattern “AABAACAABAA”, lps[] is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]
	//	For the pattern “ABCDE”, lps[] is [0, 0, 0, 0, 0]
	//	For the pattern “AAAAA”, lps[] is [0, 1, 2, 3, 4]
	//	For the pattern “AAABAAA”, lps[] is [0, 1, 2, 0, 1, 2, 3]
	//	For the pattern “AAACAAAAAC”, lps[] is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]
	void computePrefix(char* P, vector&lt;int&gt;&amp; pi) {
		int m=strlen(P);
		pi[0]=0; // lps[0] is always 0
		int k=0; // length of the previous prefix suffix
		int i=1;
		while(i&lt;m) {
			if(P[k]==P[i]) {
				k++;
				pi[i]=k;
				i++;
			} else {
				if(k!=0) {
					k=pi[k-1];
				} else {
					pi[i]=0;
					i++;
				}
			}
		}
	}

	void printPrefix(vector&lt;int&gt;&amp; pi) {
		cout&lt;&lt;"pi={ ";
		for(auto&amp; x:pi)
			cout&lt;&lt;x&lt;&lt;" ";
		cout&lt;&lt;"}"&lt;&lt;endl;
	}
};
</code></pre>

	</div>
	</div>
    
	
	<!-- Pagination links -->
	
	<ul class="pager">
	    
	    <li class="previous"><a href="/page2">&larr; Older</a></li>
	    
	
	    
	    <li class="next disabled"><a>Newer &rarr;</a></li>
	    
	</ul>
	
	<!-- content -->
</div>

<div class="col-lg-3">
		<div class="well">
            <h4>Links</h4>
			<a href="https://www.linkedin.com/pub/bo-yang/21/a3/893" target="_blank"> <i class="fa fa-linkedin-square fa-3x"></i> </a> 
			<a href="https://github.com/bo-yang" target="_blank"> <i class="fa fa-github fa-3x"></i> </a> 
			<a href="https://www.facebook.com/bo.yang.52493" target="_blank"> <i class="fa fa-facebook-square fa-3x"></i> </a>
			<a href="http://www.weibo.com/bonnyang" target="_blank"> <i class="fa fa-weibo fa-3x"></i> </a> 
        	<a href="/atom.xml" target="_blank"> <i class="fa fa-rss-square fa-3x"></i> </a>	
        </div>
        <!-- /well -->
        <div class="well">
			<h4>Tags</h4>
				<div class="tag_box">
				
				<!-- site_tags: C/C++,Algorithm,EMC,Fault Diagnosis,Notes,AI,Database,Unix/Linux,Personal,Telecom,Tcl/Tk,Shell,Network,Perl,Industry,Cloud Computing,API,Android,VBA,Virtualization,Browser,Plan 9,Go,Distributed Systems,Tips,Genetic Algorihtm,Mac OS,Statistics,Matlab,Multithreading,Bioinformatics,Computer Vision,Machine Learning,BACI,Jekyll,Architecture,Java -->
				
				<!-- tag_words:  -->

				
  <ul class="nav nav-pills nav-stacked">
  
    
        <li><a href="/tags.html#AI">AI <span class="badge pull-right">7</span></a></li>
    
        <li><a href="/tags.html#API">API <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Algorithm">Algorithm <span class="badge pull-right">27</span></a></li>
    
        <li><a href="/tags.html#Android">Android <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Architecture">Architecture <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#BACI">BACI <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Bioinformatics">Bioinformatics <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Browser">Browser <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#C%2FC%2B%2B">C/C++ <span class="badge pull-right">52</span></a></li>
    
        <li><a href="/tags.html#Cloud+Computing">Cloud Computing <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Computer+Vision">Computer Vision <span class="badge pull-right">4</span></a></li>
    
        <li><a href="/tags.html#Database">Database <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Distributed+Systems">Distributed Systems <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#EMC">EMC <span class="badge pull-right">9</span></a></li>
    
        <li><a href="/tags.html#Fault+Diagnosis">Fault Diagnosis <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Genetic+Algorihtm">Genetic Algorihtm <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Go">Go <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Industry">Industry <span class="badge pull-right">6</span></a></li>
    
        <li><a href="/tags.html#Java">Java <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Jekyll">Jekyll <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Mac+OS">Mac OS <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Machine+Learning">Machine Learning <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Matlab">Matlab <span class="badge pull-right">3</span></a></li>
    
        <li><a href="/tags.html#Multithreading">Multithreading <span class="badge pull-right">2</span></a></li>
    
        <li><a href="/tags.html#Network">Network <span class="badge pull-right">4</span></a></li>
    
        <li><a href="/tags.html#Notes">Notes <span class="badge pull-right">25</span></a></li>
    
        <li><a href="/tags.html#Perl">Perl <span class="badge pull-right">15</span></a></li>
    
        <li><a href="/tags.html#Personal">Personal <span class="badge pull-right">13</span></a></li>
    
        <li><a href="/tags.html#Plan+9">Plan 9 <span class="badge pull-right">9</span></a></li>
    
        <li><a href="/tags.html#Shell">Shell <span class="badge pull-right">15</span></a></li>
    
        <li><a href="/tags.html#Statistics">Statistics <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Tcl%2FTk">Tcl/Tk <span class="badge pull-right">9</span></a></li>
    
        <li><a href="/tags.html#Telecom">Telecom <span class="badge pull-right">1</span></a></li>
    
        <li><a href="/tags.html#Tips">Tips <span class="badge pull-right">4</span></a></li>
    
        <li><a href="/tags.html#Unix%2FLinux">Unix/Linux <span class="badge pull-right">100</span></a></li>
    
        <li><a href="/tags.html#VBA">VBA <span class="badge pull-right">5</span></a></li>
    
        <li><a href="/tags.html#Virtualization">Virtualization <span class="badge pull-right">4</span></a></li>
    
  
  </ul>




				</div>
		</div>
		<!-- /well -->
        <div class="well">
			<h4>Visitors</h4>
				<script type="text/javascript" src="http://je.revolvermaps.com/2/1.js?i=4gy6jc9lpsq&amp;s=220&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=ff0000" async="async"></script>
	
        </div>
		<!-- /well -->
		<!--
        <div class="well">
            <h3>Recent Posts</h3>
	        <ul>
			
  			<li><span>2014-08-03</span> &raquo; <a href="/2014/08/03/string-permutation">String Permutation</a></li>
			
  			<li><span>2014-07-28</span> &raquo; <a href="/2014/07/28/word-search">Word Search Problem - Non-recursive Solution</a></li>
			
  			<li><span>2014-07-21</span> &raquo; <a href="/2014/07/21/merge-k-sorted-lists">Merge K Sorted Lists</a></li>
			
  			<li><span>2014-07-14</span> &raquo; <a href="/2014/07/14/insertion-sort-list">Insertion Sort List</a></li>
			
  			<li><span>2014-07-13</span> &raquo; <a href="/2014/07/13/linked-list-cycle">Linked List Cycle Problems</a></li>
			
  			<li><span>2014-07-08</span> &raquo; <a href="/2014/07/08/sort-list">Sort List</a></li>
			
  			<li><span>2014-07-07</span> &raquo; <a href="/2014/07/07/subset-sum">Subset Sum Problem</a></li>
			
  			<li><span>2014-07-07</span> &raquo; <a href="/2014/07/07/determine-top-common-ip-addresses">Find Top Source IP Addresses in Distributed Systems</a></li>
			
  			<li><span>2014-07-06</span> &raquo; <a href="/2014/07/06/longest-palindromic-substring">Longest Palindromic Substring</a></li>
			
  			<li><span>2014-07-01</span> &raquo; <a href="/2014/07/01/strstr">The First Occurrence of Needle In Haystack</a></li>
			
			</ul>
		</div>
		-->
        <!-- /well -->
</div>

	</div>
</div>


    </div>

    <footer>
        <p>&copy; 2007 <span id="now_year"></span> Bo Yang. </p>
        <script type="text/javascript">
          var now_year = new Date().getFullYear();
          if (now_year != 2007) {
              $('#now_year').html('- ' + now_year);
          }
	    </script>
      </footer>
  </div>

  <script type="text/javascript" src="/assets/google-code-prettify/prettify.js"></script>
  <script src="/assets/run_prettify.js"></script>
  <script type="text/javascript">
    $(function() {

      $('a[href^="http"]').each(function () {
        $(this).attr('target', '_blank');
      });

      $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto');
      window.prettyPrint && prettyPrint();

      function traverse($node, len, maxCount) {
        var reachMaxCount = len > maxCount;
        if (reachMaxCount) {
          $node.hide();
        }
        var $contents = $node.contents();
        for (var i = 0; i < $contents.length; ++i) {
          if (reachMaxCount) {
            $contents.eq(i).hide();
            continue;
          }
          if ($contents[i].nodeType == 3) { // TextNode
            var tmp = len;
            var s = $contents[i].nodeValue;
            len += s.length;
            reachMaxCount = len > maxCount;
            if (reachMaxCount && $contents[i].parentNode.nodeName != 'A') {
              $contents[i].nodeValue = s.substring(0, maxCount - tmp);
            }
          }
          else if ($contents[i].nodeType == 1) { // Element
            len = traverse($contents.eq(i), len, maxCount);
          }
        }
        return len;
      }

      $('.post_at_index').each(function() {
        var count = traverse($(this), 0, 400);
        if (count > 400) {
          var thisUrl = $(this).siblings().first().children().attr('href');
          $(this).after('\n<a href="' + thisUrl + '" rel="nofollow" class="btn btn-primary" role="button">' + 'Read More &raquo;</a>');
        }
      });
    });
  </script>

  

</body>
</html>

