<!DOCTYPE html>
<html lang="en">
<head>
  <title>John Duff - Home </title>
  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
  <meta name="verify-v1" content="fI45uNHehVNiO9Dt0Fp7XnsV0Z/ozBTkPoS6RlYAe50=" />
  <meta name="y_key" content="6c948e75a617b12d" />
  <meta name='technorati-claim' content='8QN7CWNH8BSJ' />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" media="screen" href="/css/bootstrap.css">
  <link rel="stylesheet" type="text/css" href="/css/default.css" />
  <link rel="stylesheet" type="text/css" href="/css/syntax.css" />
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="John Duff's blog" />
</head>

<body class='blog'>
  <div class="container">
    <div class="row">
      <div class="span4 sidebar affix">
        <div class="well">
          <h2 class='site-title'>
            <a href="http://bo-yang.github.io">Bo Yang</a>
          </h2>

		  <p><i>You got to make the back of the fence that nobody will see just as good looking as the front of the fence.</i></p>

          <ul id="navigation" class="clearfix">
            <li class='about'><a href='/about/'>About</a></li>
            <li class='archives'><a href='/archives/'>Archives</a></li>
            <li class="github"><a href="http://github.com/bo-yang" rel='me' class='url'>@github</a></li>
          </ul>
        </div>
      </div>
      <div class="span8 main offset4">
        <div class="well">
          <div id='index'>

  <div class="post">
    <h2><a href="/bkup/2013/05/16/counting-unique-k-mers-my-first-go-program/">Counting Unique k-mers -- My First Go Program</a></h2>

    <p>Previously, I wrote a Perl program to count the number of unique k-mers. It is very convenient to implement it in Perl, because Perl supports hash-of-hashes(which could dynamically count distinct k-mers) and sorting hashes by value(which can easily list the occurrences of unique k-mers in descending order).</p>
<p>Unfortunately, comparing to C++, Perl program usually costs more memory and longer time. This is not a big issue when the FASTA files are not large(smaller than 400MB). However, when handling larger FASTA files, my Perl program would require more than 8GB memory, which exceeds the limits of my computer. Therefore, I decided to rewrite the program by Go, a system language that supports concurrent features and can has C/C++-comparable speed.</p>
<p>The syntax of Go is very different from C/C++, which takes me a whole day familiarize. Some operations that can be implemented easily in Perl can only be done in complicated way, such as calling system command, reading file line-by-line, writing file and sorting map by value. Since this small tool doesn't involve network and concurrency, I cannot compare the difficulty of writing Go program to implement such work. </p>
<p>Although the experience of the first Go program is not happy, I still think it is necessary to continue learning Go language, because Go program really runs very fast and saves memory(comparing to Perl script). And you don't need to worry about the tricky part of C++. </p>
<pre>
// kmerfreq - count unique k-mers from a fasta file.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"strconv"
)

// Readln returns a single line (without the ending \n)
// from the input buffered reader.
// An error is returned iff there is an error with the
// buffered reader.
func Readln(r *bufio.Reader) (string, error) {
	var (
		isPrefix bool  = true
		err      error = nil
		line, ln []byte
	)
	for isPrefix &amp;&amp; err == nil {
		line, isPrefix, err = r.ReadLine()
		ln = append(ln, line...)
	}
	return string(ln), err
}

func main() {
	// Get options
	var input = flag.String("i", "", "input fasta file")
	var kmer = flag.Int("k", 16, "length of k-mer")
	flag.Parse()

	// Dynamically parse the input file name
	cmd := exec.Command("basename", *input)
	cmd.Stdin = strings.NewReader("some input")
	var name bytes.Buffer
	cmd.Stdout = &amp;name
	err := cmd.Run()
	if err != nil {
		fmt.Println(err)
		return
	}
	var output = flag.String("o", fmt.Sprintf("%s.%d-mer", strings.TrimSpace(name.String()), *kmer), "output file")
	flag.Parse()

	// open input file
	fi, err := os.Open(*input)
	if err != nil {
		panic(err)
	}
	// close fi on exit and check for its returned error
	defer func() {
		if err := fi.Close(); err != nil {
			panic(err)
		}
	}()

	// open output file
	fo, err := os.Create(*output)
	if err != nil {
		panic(err)
	}
	// close fo on exit and check for its returned error
	defer func() {
		if err := fo.Close(); err != nil {
			panic(err)
		}
	}()

	// Read and count unique k-mers
	var read string = ""
	var km map[string]int  // k-mer counts
	km = make(map[string]int)

	r := bufio.NewReader(fi)
	for {
		line, err := Readln(r)
		if err == io.EOF {
			if !strings.HasPrefix(line, "&gt;") {
				read += line
			}
			break // done
		} else if err != nil {
			panic(err) // error happens
		}
		if strings.HasPrefix(line, "&gt;") {
			// Header of the read
			if len(read) != 0 {
				// count k-mers
				for i := 0; i &lt; len(read)-*kmer+1; i++ {
					if km[read[i:i+*kmer]] != 0 {
						km[read[i:i+*kmer]]++
					} else {
						km[read[i:i+*kmer]] = 1
					}
				}
				read = &quot;&quot;
			}
		} else {
			// Read
			read += line
		}
	} // end of for

	// don&#039;t forget the last read
	if len(read) != 0 {
		// count k-mers
		for i := 0; i &lt; len(read)-*kmer+1; i++ {
			if km[read[i:i+*kmer]] != 0 {
				km[read[i:i+*kmer]]++
			} else {
				km[read[i:i+*kmer]] = 1
			}
		}
	}

	// Write results
	for k, v := range km {
		fo.WriteString(k + &quot;\t&quot; + strconv.Itoa(v) + &quot;\n&quot;)
	}
}
</pre>
<p>&nbsp;</p>


    <small class="meta">May 16, 2013 | <a href='/bkup/2013/05/16/counting-unique-k-mers-my-first-go-program/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/bioinformatics/go/2013/05/16/counting-unique-k-mers-my-first-go-program/">Counting Unique k-mers -- My First Go Program</a></h2>

    <p>Previously, I wrote a Perl program to count the number of unique k-mers. It is very convenient to implement it in Perl, because Perl supports hash-of-hashes(which could dynamically count distinct k-mers) and sorting hashes by value(which can easily list the occurrences of unique k-mers in descending order).</p>
<p>Unfortunately, comparing to C++, Perl program usually costs more memory and longer time. This is not a big issue when the FASTA files are not large(smaller than 400MB). However, when handling larger FASTA files, my Perl program would require more than 8GB memory, which exceeds the limits of my computer. Therefore, I decided to rewrite the program by Go, a system language that supports concurrent features and can has C/C++-comparable speed.</p>
<p>The syntax of Go is very different from C/C++, which takes me a whole day familiarize. Some operations that can be implemented easily in Perl can only be done in complicated way, such as calling system command, reading file line-by-line, writing file and sorting map by value. Since this small tool doesn't involve network and concurrency, I cannot compare the difficulty of writing Go program to implement such work. </p>
<p>Although the experience of the first Go program is not happy, I still think it is necessary to continue learning Go language, because Go program really runs very fast and saves memory(comparing to Perl script). And you don't need to worry about the tricky part of C++. </p>
<pre>
// kmerfreq - count unique k-mers from a fasta file.

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"
	"strconv"
)

// Readln returns a single line (without the ending \n)
// from the input buffered reader.
// An error is returned iff there is an error with the
// buffered reader.
func Readln(r *bufio.Reader) (string, error) {
	var (
		isPrefix bool  = true
		err      error = nil
		line, ln []byte
	)
	for isPrefix &amp;&amp; err == nil {
		line, isPrefix, err = r.ReadLine()
		ln = append(ln, line...)
	}
	return string(ln), err
}

func main() {
	// Get options
	var input = flag.String("i", "", "input fasta file")
	var kmer = flag.Int("k", 16, "length of k-mer")
	flag.Parse()

	// Dynamically parse the input file name
	cmd := exec.Command("basename", *input)
	cmd.Stdin = strings.NewReader("some input")
	var name bytes.Buffer
	cmd.Stdout = &amp;name
	err := cmd.Run()
	if err != nil {
		fmt.Println(err)
		return
	}
	var output = flag.String("o", fmt.Sprintf("%s.%d-mer", strings.TrimSpace(name.String()), *kmer), "output file")
	flag.Parse()

	// open input file
	fi, err := os.Open(*input)
	if err != nil {
		panic(err)
	}
	// close fi on exit and check for its returned error
	defer func() {
		if err := fi.Close(); err != nil {
			panic(err)
		}
	}()

	// open output file
	fo, err := os.Create(*output)
	if err != nil {
		panic(err)
	}
	// close fo on exit and check for its returned error
	defer func() {
		if err := fo.Close(); err != nil {
			panic(err)
		}
	}()

	// Read and count unique k-mers
	var read string = ""
	var km map[string]int  // k-mer counts
	km = make(map[string]int)

	r := bufio.NewReader(fi)
	for {
		line, err := Readln(r)
		if err == io.EOF {
			if !strings.HasPrefix(line, "&gt;") {
				read += line
			}
			break // done
		} else if err != nil {
			panic(err) // error happens
		}
		if strings.HasPrefix(line, "&gt;") {
			// Header of the read
			if len(read) != 0 {
				// count k-mers
				for i := 0; i &lt; len(read)-*kmer+1; i++ {
					if km[read[i:i+*kmer]] != 0 {
						km[read[i:i+*kmer]]++
					} else {
						km[read[i:i+*kmer]] = 1
					}
				}
				read = &quot;&quot;
			}
		} else {
			// Read
			read += line
		}
	} // end of for

	// don&#039;t forget the last read
	if len(read) != 0 {
		// count k-mers
		for i := 0; i &lt; len(read)-*kmer+1; i++ {
			if km[read[i:i+*kmer]] != 0 {
				km[read[i:i+*kmer]]++
			} else {
				km[read[i:i+*kmer]] = 1
			}
		}
	}

	// Write results
	for k, v := range km {
		fo.WriteString(k + &quot;\t&quot; + strconv.Itoa(v) + &quot;\n&quot;)
	}
}
</pre>
<p>&nbsp;</p>


    <small class="meta">May 16, 2013 | <a href='/bioinformatics/go/2013/05/16/counting-unique-k-mers-my-first-go-program/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/bkup/2013/04/05/linear-space-sequence-alignment/">Linear Space Sequence Alignment</a></h2>

    <p>For explanation to linear space sequence alignment, please refer to <a href="http://ai.stanford.edu/~serafim/CS262_2007/notes/lecture3.pdf">http://ai.stanford.edu/~serafim/CS262_2007/notes/lecture3.pdf</a>.</p>
<p>The algorithm and equation I used was from the textbook <em>Algorithm Design</em> by Jon Kleinberg and Éva Tardos(2005):</p>
<p><a href="http://bonny95.files.wordpress.com/2013/04/align-equation.png"><img class="alignnone size-full wp-image-531" alt="align-equation" src="http://bonny95.files.wordpress.com/2013/04/align-equation.png" width="529" height="134" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/align-alg.png"><img class="alignnone size-full wp-image-530" alt="align-alg" src="http://bonny95.files.wordpress.com/2013/04/align-alg.png" width="529" height="236" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/space-efficient-equation.png"><img class="alignnone size-full wp-image-529" alt="space-efficient-equation" src="http://bonny95.files.wordpress.com/2013/04/space-efficient-equation.png" width="529" height="66" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/space-efficient-akg.png"><img class="alignnone size-full wp-image-528" alt="space-efficient-akg" src="http://bonny95.files.wordpress.com/2013/04/space-efficient-akg.png" width="529" height="277" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/divide-conquer.png"><img class="alignnone size-full wp-image-527" alt="divide-conquer" src="http://bonny95.files.wordpress.com/2013/04/divide-conquer.png" width="529" height="283" /></a></p>
<p>The algorithm of Backward-Space-Efficient-Alignment() is the reverse of Space-Efficient-Alignment().</p>
<p><a href="http://bonny95.files.wordpress.com/2013/04/time_cost_plot.png"><img class="alignnone size-full wp-image-532" alt="time_cost_plot" src="http://bonny95.files.wordpress.com/2013/04/time_cost_plot.png" width="529" height="398" /></a></p>
<p>Time cost of sequences from 10bp-510bp.</p>
<p><a href="http://bonny95.files.wordpress.com/2013/04/memory_cost_plot.png"><img class="alignnone size-full wp-image-533" alt="memory_cost_plot" src="http://bonny95.files.wordpress.com/2013/04/memory_cost_plot.png" width="529" height="395" /></a></p>
<p>Memory cost of sequences from 10bp-510bp.</p>
<pre class="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;

using namespace std;

const int MATCH_COST=0;
const int MISMATCH_COST=2;
const int GAP_COST=1;

int memcnt=0; // counting memory allocated

struct BTNode
{
	int x; // x axis
	int y; // y axis
	char type; // 'm'-match,'s'-mismatch,'g'-gap
	char nt; // valid neucleotide: x-sequence x, y-sequence y, b-both 
};

BTNode* P;
int pidx=0; // index of P

struct Region // region in a sequence
{
	int start; 
	int end;
};

//
// Generate random sequence
// 
char* GenRandSeq(char* seq, int n)
{
	string nt="ATCG";
	for(int i=0;i&lt;n;++i)
	{
		int idx=rand()%4;
		seq[i]=nt[idx];
	}

	return seq;
}

int min(int a,int b,int c)
{
	return (a&lt;b?a:b)&lt;c?(a&lt;b?a:b):c;
}

void Merge(BTNode* input, long p, long r)
{
	long mid = floor((p + r) / 2);
	long i1 = 0;
	long i2 = p;
	long i3 = mid + 1;

	// Temp array
	BTNode* temp=new BTNode[r-p+1];
	memcnt+=sizeof(BTNode)*(r-p+1);

	// Merge in sorted form the 2 arrays
	while ( i2 &lt;= mid &amp;&amp; i3 &lt;= r )
		if ( input[i2].x &lt; input[i3].x )
			temp[i1++] = input[i2++];
		else
			temp[i1++] = input[i3++];

	// Merge the remaining elements in left array
	while ( i2 &lt;= mid )
		temp[i1++] = input[i2++];

	// Merge the remaining elements in right array
	while ( i3 &lt;= r )
		temp[i1++] = input[i3++];

	// Move from temp array to master array
	for ( int i = p; i &lt;= r; i++ )
		input[i] = temp[i-p];

	delete [] temp;
}

// Merge sort the BTNode array by the first index(element x)
//
// inputs:
//	p - the start index of array input
//	r - the end index of array input
void Merge_sort(BTNode* input, long p, long r)
{
	if ( p &lt; r )
	{
		long mid = floor((p + r) / 2);
		Merge_sort(input, p, mid);
		Merge_sort(input, mid + 1, r);
		Merge(input, p, r);
	}
}

//
// Insert new node into P
//
void InsertNodetoP(int x, int y)
{
	bool isok=true;
	for(int i=0;i&lt;pidx;++i)
	{
		if(x==P[i].x &amp;&amp; y==P[i].y)
			isok=false;
	}
	if(isok)
	{
		P[pidx].x=x;
		P[pidx].y=y;
		pidx++;
	}
}

//
// Align seqences
//
// Recurrence:
// 	OPT(i,j)=min{   
// 			alpha(i,j)+OPT(i-1,j-1), 
// 			delta+OPT(i-1,j), 
// 			delta+OPT(i,j-1)
// 		}
// 	where mismatch cost alpha=2, match cost alpha=0, and gap cost delta=1.
//
// Parameters:
//	X,Y - sequences
//	m - length of sequence X
//	n - length of sequence Y
//
int Alignment(char* X, Region&amp; rx, char* Y, Region&amp; ry)
{
	int m=rx.end-rx.start+1;
	int n=ry.end-ry.start+1;

	int** S=new int*[m+1]; // temp array to store scores of alignment
	for(int i=0;i&lt;m+1;++i)
		S[i]=new int[n+1];
	memcnt+=sizeof(int)*(m+1)*(n+1);

	for(int i=0;i&lt;=m;++i)
		S[i][0]=i*GAP_COST;
	for(int j=0;j&lt;=n;++j)
		S[0][j]=j*GAP_COST;

	for(int j=1;j&lt;=n;++j)
	{
		for(int i=1;i&lt;=m;++i)
		{
			int alpha;
			if(X[i-1]==Y[j-1])
				alpha=MATCH_COST;
			else
				alpha=MISMATCH_COST;

			S[i][j]=min(alpha+S[i-1][j-1],GAP_COST+S[i-1][j],GAP_COST+S[i][j-1]);
		}
	} // end of for

	// Trace back 
	int ix=m;
	int iy=n;
	int bt_len=m+n;// length of array to record tracing back
	int cnt=bt_len-1; 	
	BTNode* bt=new BTNode[bt_len]; // record backtrace path
	memcnt+=sizeof(BTNode)*bt_len;
	while(ix&gt;=1 &amp;&amp; iy&gt;=1)
	{
		bt[cnt].x=ix-1;
		bt[cnt].y=iy-1;
		InsertNodetoP(rx.start+ix-1,ry.start+iy-1);

		if(S[ix][iy]==S[ix-1][iy-1]+MATCH_COST &amp;&amp; X[ix-1]==Y[iy-1]) // match
		{
			bt[cnt].type='m';
			bt[cnt].nt='b';
			ix--;
			iy--;
		} else if(S[ix][iy]==S[ix-1][iy-1]+MISMATCH_COST) { // mismatch
			bt[cnt].type='s';
			bt[cnt].nt='b';
			ix--;
			iy--;
		} else if(S[ix][iy]==S[ix-1][iy]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='x';
			ix--;
		} else if(S[ix][iy]==S[ix][iy-1]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='y';
			iy--;
		} 	
		cnt--;
	}
	while(iy&gt;0)
	{
		bt[cnt].x=ix-1;
		bt[cnt].y=iy-1;
		InsertNodetoP(rx.start+ix-1,ry.start+iy-1);

		if(S[ix][iy]==S[ix][iy-1]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='y';
			iy--;
		}
		cnt--;
	}
	while(ix&gt;0)
	{
		bt[cnt].x=ix-1;
		bt[cnt].y=iy-1;
		InsertNodetoP(rx.start+ix-1,ry.start+iy-1);

		if(S[ix][iy]==S[ix-1][iy]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='x';
			ix--;
		}
		cnt--;
	}

/*	// Print the alignment
  	cnt++;
	// TEST ONLY
	for(int i=cnt;i&lt;bt_len;++i)
	{
		cout&lt;&lt;"("&lt;&lt;bt[i].x&lt;&lt;","&lt;&lt;bt[i].y&lt;&lt;") ";
	}
	cout&lt;&lt;endl;

	// Print sequence X
	for(int i=cnt;i&lt;bt_len;++i)
	{
		if(bt[i].nt=='x'||bt[i].nt=='b')
		{
			if(bt[i].x&lt;0)
				cout&lt;&lt;'-';
			else
				cout&lt;&lt;X[bt[i].x];
		} else {
			cout&lt;&lt;'-';
		}
	}
	cout&lt;&lt;endl;
	// print middle line
	for(int i=cnt;i&lt;bt_len;++i)
	{
		if(bt[i].type=='m')
			cout&lt;&lt;'|';
		else
			cout&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	// print sequence Y
	for(int i=cnt;i&lt;bt_len;++i)
	{
		if(bt[i].nt=='y'||bt[i].nt=='b')
		{
			if(bt[i].y&lt;0)
				cout&lt;&lt;'-';
			else
				cout&lt;&lt;Y[bt[i].y];
		} else {
			cout&lt;&lt;'-';
		}
	}
	cout&lt;&lt;endl; */

	delete [] bt;

	int score=S[m][n];

	for(int i=0;i&lt;m+1;++i)
		delete [] S[i];
	delete [] S;

	return score;
}

// 
// Space efficient alignment, which caculate the length of the 
// shortest path from (0,0) to (i,j) and only can returns the optimal value.
//
int SpaceEfficientAlignment(int** S, char* X, int m, char* Y, int n)
{
	for(int i=0;i&lt;=m;++i)
	{
		S[i][0]=i*GAP_COST;
	}

	for(int j=1;j&lt;=n;++j)
	{
		S[0][1]=j*GAP_COST;
		for(int i=1;i&lt;=m;++i)
		{
			int alpha;
			if(X[i-1]==Y[j-1])
				alpha=MATCH_COST;
			else
				alpha=MISMATCH_COST;

			S[i][1]=min(alpha+S[i-1][0],GAP_COST+S[i-1][1],GAP_COST+S[i][0]);
		}

		// move column 1 of S to column 0 to make room for next iteration
		for(int i=0;i&lt;=m;++i)
			S[i][0]=S[i][1];
	}

	return S[m][1];
}

// 
// Backward space efficient alignment, which caculate the length of the 
// shortest path from (i,j) to (m,n) and only can returns the optimal value.
//
int BackwardSpaceEfficientAlignment(int** S, char* X, int m, char* Y, int n)
{
	for(int i=m;i&gt;=0;--i)
	{
		S[i][1]=(m-i)*GAP_COST;
	}

	for(int j=n-1;j&gt;=0;--j)
	{
		S[m][0]=(n-j)*GAP_COST;
		for(int i=m-1;i&gt;=0;--i)
		{
			int alpha;
			//if(X[m-i-1]==Y[j])
			if(X[i]==Y[j])
				alpha=MATCH_COST;
			else
				alpha=MISMATCH_COST;

			S[i][0]=min(alpha+S[i+1][1],GAP_COST+S[i+1][0],GAP_COST+S[i][1]);
		}

		// move column 0 of S to column 1 to make room for next iteration
		for(int i=0;i&lt;=m;++i)
			S[i][1]=S[i][0];
	}

	return S[0][0];
}

// 
// Find out the q that minimize the score f(q,n/2)+g(q,n/2)
//
// Inputs:
// 	sf - score vector of forward space efficient alignment
// 	sb - score vector of backward space efficient alignment
// 	m - length of the score vector
//
int FindMinScore(int** sf,int** sb,int m)
{
	int min=sf[1][1]+sb[1][0];
	int ret=1;
	for(int q=2;q&lt;=m;++q)
	{
		if(min&gt;sf[q][1]+sb[q][0])
		{
			min=sf[q][1]+sb[q][0];
			ret=q-1; // ret should be the position in the sequence, so minus 1
		}
	}

	return ret;
}

//
// Sequence alignemnt using divide and conquer
//
void DivideConquerAlignment(char* X, Region&amp; rx, char* Y, Region&amp; ry)
{
	int m=rx.end-rx.start+1;
	int n=ry.end-ry.start+1;

	if(m&lt;=2 || n&lt;=2)
	{
		Alignment(&amp;X[rx.start],rx,&amp;Y[ry.start],ry);
//		cout&lt;&lt;"Call Alignment"&lt;&lt;endl; // TEST ONLY
		return;
	}

	int** score_forward=new int*[m+1]; // (m+1)x2 matrix to store scores of alignment
	int** score_backward=new int*[m+1]; // (m+1)x2 matrix to store scores of alignment
	for(int i=0;i&lt;m+1;++i)
	{
		score_forward[i]=new int[2];
		score_backward[i]=new int[2];
	}
	memcnt+=sizeof(int)*2*(m+1)*2;

	// Get the middle points in path
	Region tempry;
	tempry.start=ry.start;
	tempry.end=(ry.start+ry.end)/2;
	SpaceEfficientAlignment(score_forward,&amp;X[rx.start],m,&amp;Y[tempry.start],tempry.end-tempry.start+1);
	tempry.start=(ry.start+ry.end)/2+1;
	tempry.end=ry.end;
	BackwardSpaceEfficientAlignment(score_backward,&amp;X[rx.start],m,&amp;Y[tempry.start],tempry.end-tempry.start+1);

	int q=FindMinScore(score_forward,score_backward,m)+rx.start;
//	cout&lt;&lt;"q="&lt;&lt;q&lt;&lt;", n/2="&lt;&lt;(ry.start+ry.end)/2&lt;&lt;endl; // TEST ONLY
	InsertNodetoP(q,(ry.start+ry.end)/2);

	// Divide and Conquer
	Region temprx;
	temprx.start=rx.start;
	temprx.end=q;
	tempry.start=ry.start;
	tempry.end=(ry.start+ry.end)/2;
	if(temprx.start&lt;=temprx.end &amp;&amp; tempry.start&lt;=tempry.end)
		DivideConquerAlignment(X,temprx,Y,tempry);
	temprx.start=q+1;
	temprx.end=rx.end;
	tempry.start=(ry.start+ry.end)/2+1;
	tempry.end=ry.end;
	if(temprx.start&lt;=temprx.end &amp;&amp; tempry.start&lt;=tempry.end)
		DivideConquerAlignment(X,temprx,Y,tempry);

	for(int i=0;i&lt;m+1;++i)
	{
		delete [] score_forward[i];
		delete [] score_backward[i];
	}
	delete [] score_forward;
	delete [] score_backward;
}

// 
// Backtrace and print the alignment
//
void Backtrace(char* X,char* Y)
{
	Merge_sort(P,0,pidx-1); // Sort nodes in path according to element x
	// Adjust all nodes in path by element y
	int prev_x=-1,prev_y=-1;
	BTNode temp;
	for(int i=0;i&lt;pidx;++i)
	{
		if(prev_y&gt;P[i].y)
		{
			temp=P[i-1];
			P[i-1]=P[i];
			P[i]=temp;
		}
		prev_y=P[i].y;
	}

//	for(int i=0;i&lt;pidx;++i)
//		cout&lt;&lt;"("&lt;&lt;P[i].x&lt;&lt;","&lt;&lt;P[i].y&lt;&lt;")"&lt;&lt;" "; //TEST ONLY
//	cout&lt;&lt;endl; // TEST ONLY

	// Print sequence X
	prev_x=-1;
	for(int i=0;i&lt;pidx;++i)
	{
		if(P[i].x&lt;0 || P[i].x==prev_x)
			cout&lt;&lt;'-';
		else
			cout&lt;&lt;X[P[i].x];
		prev_x=P[i].x;
	}
	cout&lt;&lt;endl;

	// Print middle line
	prev_x=-1;
	prev_y=-1;
	for(int i=0;i&lt;pidx;++i)
	{
		if(X[P[i].x]==Y[P[i].y] &amp;&amp; prev_x!=P[i].x &amp;&amp; prev_y!=P[i].y)
			cout&lt;&lt;'|';
		else
			cout&lt;&lt;' ';
		prev_x=P[i].x;
		prev_y=P[i].y;
	}
	cout&lt;&lt;endl;

	// Print sequence Y
	prev_y=-1;
	for(int i=0;i&lt;pidx;++i)
	{
		if(P[i].y&lt;0 || P[i].y==prev_y)
			cout&lt;&lt;'-';
		else
			cout&lt;&lt;Y[P[i].y];
		prev_y=P[i].y;
	}
	cout&lt;&lt;endl;

}

//
// MAIN START HERE
//
int main(int argc, char** argv)
{
	// initialize random seed
	srand(time(NULL));

	char* output=NULL;	// output file
	int seqlen=0;		// sequence length
	int c;

	while ((c = getopt (argc, argv, "n:o:")) != -1)
	{
		switch (c)
           	{
		case 'n':
             		seqlen = atoi(optarg); 
             		break;
		case 'o':
             		output = optarg; 
             		break;
           	case '?':
             		if (optopt == 'n')
              			fprintf (stderr, "Option -%c requires an argument.\n\n", optopt);
             		else if (isprint (optopt))
               			fprintf (stderr, "Unknown option `-%c'.\n\n", optopt);
             		else
               			fprintf (stderr,
                        		"Unknown option character `\x%x'.\n\n",
                        		optopt);
             		return 1;
           	default:
             		abort ();
           	}
	}

	int m=seqlen;
	int n=seqlen-rand()%(seqlen/5);

	char* ref=new char[m];
	char* seq=new char[n];
	memcnt+=sizeof(char)*(m+n);

	// generate random sequences
	ref=GenRandSeq(ref,m);
	seq=GenRandSeq(seq,n);

	P=new BTNode[m+n];
	memcnt+=sizeof(BTNode)*(m+n);

	cout&lt;&lt;"seq 1:"&lt;&lt;ref&lt;&lt;endl; // TEST ONLY
	cout&lt;&lt;"seq 2:"&lt;&lt;seq&lt;&lt;endl; // TEST ONLY

	Region rx, ry;
	rx.start=0;
	rx.end=m-1;
	ry.start=0;
	ry.end=n-1;
//	Alignment(ref,rx,seq,ry); // TEST ONLY

	DivideConquerAlignment(ref,rx,seq,ry);

	Backtrace(ref,seq);

	delete [] ref;
	delete [] seq;
	delete [] P;

	// Record the space costs
	fstream fs;
	fs.open("memory_cost", fstream::out|fstream::app);
	fs&lt;&lt;m&lt;&lt;"bp: "&lt;&lt;memcnt&lt;&lt;endl;
	fs.close();

	return 0;
}</pre>


    <small class="meta">April 05, 2013 | <a href='/bkup/2013/04/05/linear-space-sequence-alignment/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/2013/04/05/linear-space-sequence-alignment/">Linear Space Sequence Alignment</a></h2>

    <p>For explanation to linear space sequence alignment, please refer to <a href="http://ai.stanford.edu/~serafim/CS262_2007/notes/lecture3.pdf">http://ai.stanford.edu/~serafim/CS262_2007/notes/lecture3.pdf</a>.</p>
<p>The algorithm and equation I used was from the textbook <em>Algorithm Design</em> by Jon Kleinberg and Éva Tardos(2005):</p>
<p><a href="http://bonny95.files.wordpress.com/2013/04/align-equation.png"><img class="alignnone size-full wp-image-531" alt="align-equation" src="http://bonny95.files.wordpress.com/2013/04/align-equation.png" width="529" height="134" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/align-alg.png"><img class="alignnone size-full wp-image-530" alt="align-alg" src="http://bonny95.files.wordpress.com/2013/04/align-alg.png" width="529" height="236" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/space-efficient-equation.png"><img class="alignnone size-full wp-image-529" alt="space-efficient-equation" src="http://bonny95.files.wordpress.com/2013/04/space-efficient-equation.png" width="529" height="66" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/space-efficient-akg.png"><img class="alignnone size-full wp-image-528" alt="space-efficient-akg" src="http://bonny95.files.wordpress.com/2013/04/space-efficient-akg.png" width="529" height="277" /></a> <a href="http://bonny95.files.wordpress.com/2013/04/divide-conquer.png"><img class="alignnone size-full wp-image-527" alt="divide-conquer" src="http://bonny95.files.wordpress.com/2013/04/divide-conquer.png" width="529" height="283" /></a></p>
<p>The algorithm of Backward-Space-Efficient-Alignment() is the reverse of Space-Efficient-Alignment().</p>
<p><a href="http://bonny95.files.wordpress.com/2013/04/time_cost_plot.png"><img class="alignnone size-full wp-image-532" alt="time_cost_plot" src="http://bonny95.files.wordpress.com/2013/04/time_cost_plot.png" width="529" height="398" /></a></p>
<p>Time cost of sequences from 10bp-510bp.</p>
<p><a href="http://bonny95.files.wordpress.com/2013/04/memory_cost_plot.png"><img class="alignnone size-full wp-image-533" alt="memory_cost_plot" src="http://bonny95.files.wordpress.com/2013/04/memory_cost_plot.png" width="529" height="395" /></a></p>
<p>Memory cost of sequences from 10bp-510bp.</p>
<pre class="cpp">#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;

using namespace std;

const int MATCH_COST=0;
const int MISMATCH_COST=2;
const int GAP_COST=1;

int memcnt=0; // counting memory allocated

struct BTNode
{
	int x; // x axis
	int y; // y axis
	char type; // 'm'-match,'s'-mismatch,'g'-gap
	char nt; // valid neucleotide: x-sequence x, y-sequence y, b-both 
};

BTNode* P;
int pidx=0; // index of P

struct Region // region in a sequence
{
	int start; 
	int end;
};

//
// Generate random sequence
// 
char* GenRandSeq(char* seq, int n)
{
	string nt="ATCG";
	for(int i=0;i&lt;n;++i)
	{
		int idx=rand()%4;
		seq[i]=nt[idx];
	}

	return seq;
}

int min(int a,int b,int c)
{
	return (a&lt;b?a:b)&lt;c?(a&lt;b?a:b):c;
}

void Merge(BTNode* input, long p, long r)
{
	long mid = floor((p + r) / 2);
	long i1 = 0;
	long i2 = p;
	long i3 = mid + 1;

	// Temp array
	BTNode* temp=new BTNode[r-p+1];
	memcnt+=sizeof(BTNode)*(r-p+1);

	// Merge in sorted form the 2 arrays
	while ( i2 &lt;= mid &amp;&amp; i3 &lt;= r )
		if ( input[i2].x &lt; input[i3].x )
			temp[i1++] = input[i2++];
		else
			temp[i1++] = input[i3++];

	// Merge the remaining elements in left array
	while ( i2 &lt;= mid )
		temp[i1++] = input[i2++];

	// Merge the remaining elements in right array
	while ( i3 &lt;= r )
		temp[i1++] = input[i3++];

	// Move from temp array to master array
	for ( int i = p; i &lt;= r; i++ )
		input[i] = temp[i-p];

	delete [] temp;
}

// Merge sort the BTNode array by the first index(element x)
//
// inputs:
//	p - the start index of array input
//	r - the end index of array input
void Merge_sort(BTNode* input, long p, long r)
{
	if ( p &lt; r )
	{
		long mid = floor((p + r) / 2);
		Merge_sort(input, p, mid);
		Merge_sort(input, mid + 1, r);
		Merge(input, p, r);
	}
}

//
// Insert new node into P
//
void InsertNodetoP(int x, int y)
{
	bool isok=true;
	for(int i=0;i&lt;pidx;++i)
	{
		if(x==P[i].x &amp;&amp; y==P[i].y)
			isok=false;
	}
	if(isok)
	{
		P[pidx].x=x;
		P[pidx].y=y;
		pidx++;
	}
}

//
// Align seqences
//
// Recurrence:
// 	OPT(i,j)=min{   
// 			alpha(i,j)+OPT(i-1,j-1), 
// 			delta+OPT(i-1,j), 
// 			delta+OPT(i,j-1)
// 		}
// 	where mismatch cost alpha=2, match cost alpha=0, and gap cost delta=1.
//
// Parameters:
//	X,Y - sequences
//	m - length of sequence X
//	n - length of sequence Y
//
int Alignment(char* X, Region&amp; rx, char* Y, Region&amp; ry)
{
	int m=rx.end-rx.start+1;
	int n=ry.end-ry.start+1;

	int** S=new int*[m+1]; // temp array to store scores of alignment
	for(int i=0;i&lt;m+1;++i)
		S[i]=new int[n+1];
	memcnt+=sizeof(int)*(m+1)*(n+1);

	for(int i=0;i&lt;=m;++i)
		S[i][0]=i*GAP_COST;
	for(int j=0;j&lt;=n;++j)
		S[0][j]=j*GAP_COST;

	for(int j=1;j&lt;=n;++j)
	{
		for(int i=1;i&lt;=m;++i)
		{
			int alpha;
			if(X[i-1]==Y[j-1])
				alpha=MATCH_COST;
			else
				alpha=MISMATCH_COST;

			S[i][j]=min(alpha+S[i-1][j-1],GAP_COST+S[i-1][j],GAP_COST+S[i][j-1]);
		}
	} // end of for

	// Trace back 
	int ix=m;
	int iy=n;
	int bt_len=m+n;// length of array to record tracing back
	int cnt=bt_len-1; 	
	BTNode* bt=new BTNode[bt_len]; // record backtrace path
	memcnt+=sizeof(BTNode)*bt_len;
	while(ix&gt;=1 &amp;&amp; iy&gt;=1)
	{
		bt[cnt].x=ix-1;
		bt[cnt].y=iy-1;
		InsertNodetoP(rx.start+ix-1,ry.start+iy-1);

		if(S[ix][iy]==S[ix-1][iy-1]+MATCH_COST &amp;&amp; X[ix-1]==Y[iy-1]) // match
		{
			bt[cnt].type='m';
			bt[cnt].nt='b';
			ix--;
			iy--;
		} else if(S[ix][iy]==S[ix-1][iy-1]+MISMATCH_COST) { // mismatch
			bt[cnt].type='s';
			bt[cnt].nt='b';
			ix--;
			iy--;
		} else if(S[ix][iy]==S[ix-1][iy]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='x';
			ix--;
		} else if(S[ix][iy]==S[ix][iy-1]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='y';
			iy--;
		} 	
		cnt--;
	}
	while(iy&gt;0)
	{
		bt[cnt].x=ix-1;
		bt[cnt].y=iy-1;
		InsertNodetoP(rx.start+ix-1,ry.start+iy-1);

		if(S[ix][iy]==S[ix][iy-1]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='y';
			iy--;
		}
		cnt--;
	}
	while(ix&gt;0)
	{
		bt[cnt].x=ix-1;
		bt[cnt].y=iy-1;
		InsertNodetoP(rx.start+ix-1,ry.start+iy-1);

		if(S[ix][iy]==S[ix-1][iy]+GAP_COST) { // gap
			bt[cnt].type='g';
			bt[cnt].nt='x';
			ix--;
		}
		cnt--;
	}

/*	// Print the alignment
  	cnt++;
	// TEST ONLY
	for(int i=cnt;i&lt;bt_len;++i)
	{
		cout&lt;&lt;"("&lt;&lt;bt[i].x&lt;&lt;","&lt;&lt;bt[i].y&lt;&lt;") ";
	}
	cout&lt;&lt;endl;

	// Print sequence X
	for(int i=cnt;i&lt;bt_len;++i)
	{
		if(bt[i].nt=='x'||bt[i].nt=='b')
		{
			if(bt[i].x&lt;0)
				cout&lt;&lt;'-';
			else
				cout&lt;&lt;X[bt[i].x];
		} else {
			cout&lt;&lt;'-';
		}
	}
	cout&lt;&lt;endl;
	// print middle line
	for(int i=cnt;i&lt;bt_len;++i)
	{
		if(bt[i].type=='m')
			cout&lt;&lt;'|';
		else
			cout&lt;&lt;' ';
	}
	cout&lt;&lt;endl;
	// print sequence Y
	for(int i=cnt;i&lt;bt_len;++i)
	{
		if(bt[i].nt=='y'||bt[i].nt=='b')
		{
			if(bt[i].y&lt;0)
				cout&lt;&lt;'-';
			else
				cout&lt;&lt;Y[bt[i].y];
		} else {
			cout&lt;&lt;'-';
		}
	}
	cout&lt;&lt;endl; */

	delete [] bt;

	int score=S[m][n];

	for(int i=0;i&lt;m+1;++i)
		delete [] S[i];
	delete [] S;

	return score;
}

// 
// Space efficient alignment, which caculate the length of the 
// shortest path from (0,0) to (i,j) and only can returns the optimal value.
//
int SpaceEfficientAlignment(int** S, char* X, int m, char* Y, int n)
{
	for(int i=0;i&lt;=m;++i)
	{
		S[i][0]=i*GAP_COST;
	}

	for(int j=1;j&lt;=n;++j)
	{
		S[0][1]=j*GAP_COST;
		for(int i=1;i&lt;=m;++i)
		{
			int alpha;
			if(X[i-1]==Y[j-1])
				alpha=MATCH_COST;
			else
				alpha=MISMATCH_COST;

			S[i][1]=min(alpha+S[i-1][0],GAP_COST+S[i-1][1],GAP_COST+S[i][0]);
		}

		// move column 1 of S to column 0 to make room for next iteration
		for(int i=0;i&lt;=m;++i)
			S[i][0]=S[i][1];
	}

	return S[m][1];
}

// 
// Backward space efficient alignment, which caculate the length of the 
// shortest path from (i,j) to (m,n) and only can returns the optimal value.
//
int BackwardSpaceEfficientAlignment(int** S, char* X, int m, char* Y, int n)
{
	for(int i=m;i&gt;=0;--i)
	{
		S[i][1]=(m-i)*GAP_COST;
	}

	for(int j=n-1;j&gt;=0;--j)
	{
		S[m][0]=(n-j)*GAP_COST;
		for(int i=m-1;i&gt;=0;--i)
		{
			int alpha;
			//if(X[m-i-1]==Y[j])
			if(X[i]==Y[j])
				alpha=MATCH_COST;
			else
				alpha=MISMATCH_COST;

			S[i][0]=min(alpha+S[i+1][1],GAP_COST+S[i+1][0],GAP_COST+S[i][1]);
		}

		// move column 0 of S to column 1 to make room for next iteration
		for(int i=0;i&lt;=m;++i)
			S[i][1]=S[i][0];
	}

	return S[0][0];
}

// 
// Find out the q that minimize the score f(q,n/2)+g(q,n/2)
//
// Inputs:
// 	sf - score vector of forward space efficient alignment
// 	sb - score vector of backward space efficient alignment
// 	m - length of the score vector
//
int FindMinScore(int** sf,int** sb,int m)
{
	int min=sf[1][1]+sb[1][0];
	int ret=1;
	for(int q=2;q&lt;=m;++q)
	{
		if(min&gt;sf[q][1]+sb[q][0])
		{
			min=sf[q][1]+sb[q][0];
			ret=q-1; // ret should be the position in the sequence, so minus 1
		}
	}

	return ret;
}

//
// Sequence alignemnt using divide and conquer
//
void DivideConquerAlignment(char* X, Region&amp; rx, char* Y, Region&amp; ry)
{
	int m=rx.end-rx.start+1;
	int n=ry.end-ry.start+1;

	if(m&lt;=2 || n&lt;=2)
	{
		Alignment(&amp;X[rx.start],rx,&amp;Y[ry.start],ry);
//		cout&lt;&lt;"Call Alignment"&lt;&lt;endl; // TEST ONLY
		return;
	}

	int** score_forward=new int*[m+1]; // (m+1)x2 matrix to store scores of alignment
	int** score_backward=new int*[m+1]; // (m+1)x2 matrix to store scores of alignment
	for(int i=0;i&lt;m+1;++i)
	{
		score_forward[i]=new int[2];
		score_backward[i]=new int[2];
	}
	memcnt+=sizeof(int)*2*(m+1)*2;

	// Get the middle points in path
	Region tempry;
	tempry.start=ry.start;
	tempry.end=(ry.start+ry.end)/2;
	SpaceEfficientAlignment(score_forward,&amp;X[rx.start],m,&amp;Y[tempry.start],tempry.end-tempry.start+1);
	tempry.start=(ry.start+ry.end)/2+1;
	tempry.end=ry.end;
	BackwardSpaceEfficientAlignment(score_backward,&amp;X[rx.start],m,&amp;Y[tempry.start],tempry.end-tempry.start+1);

	int q=FindMinScore(score_forward,score_backward,m)+rx.start;
//	cout&lt;&lt;"q="&lt;&lt;q&lt;&lt;", n/2="&lt;&lt;(ry.start+ry.end)/2&lt;&lt;endl; // TEST ONLY
	InsertNodetoP(q,(ry.start+ry.end)/2);

	// Divide and Conquer
	Region temprx;
	temprx.start=rx.start;
	temprx.end=q;
	tempry.start=ry.start;
	tempry.end=(ry.start+ry.end)/2;
	if(temprx.start&lt;=temprx.end &amp;&amp; tempry.start&lt;=tempry.end)
		DivideConquerAlignment(X,temprx,Y,tempry);
	temprx.start=q+1;
	temprx.end=rx.end;
	tempry.start=(ry.start+ry.end)/2+1;
	tempry.end=ry.end;
	if(temprx.start&lt;=temprx.end &amp;&amp; tempry.start&lt;=tempry.end)
		DivideConquerAlignment(X,temprx,Y,tempry);

	for(int i=0;i&lt;m+1;++i)
	{
		delete [] score_forward[i];
		delete [] score_backward[i];
	}
	delete [] score_forward;
	delete [] score_backward;
}

// 
// Backtrace and print the alignment
//
void Backtrace(char* X,char* Y)
{
	Merge_sort(P,0,pidx-1); // Sort nodes in path according to element x
	// Adjust all nodes in path by element y
	int prev_x=-1,prev_y=-1;
	BTNode temp;
	for(int i=0;i&lt;pidx;++i)
	{
		if(prev_y&gt;P[i].y)
		{
			temp=P[i-1];
			P[i-1]=P[i];
			P[i]=temp;
		}
		prev_y=P[i].y;
	}

//	for(int i=0;i&lt;pidx;++i)
//		cout&lt;&lt;"("&lt;&lt;P[i].x&lt;&lt;","&lt;&lt;P[i].y&lt;&lt;")"&lt;&lt;" "; //TEST ONLY
//	cout&lt;&lt;endl; // TEST ONLY

	// Print sequence X
	prev_x=-1;
	for(int i=0;i&lt;pidx;++i)
	{
		if(P[i].x&lt;0 || P[i].x==prev_x)
			cout&lt;&lt;'-';
		else
			cout&lt;&lt;X[P[i].x];
		prev_x=P[i].x;
	}
	cout&lt;&lt;endl;

	// Print middle line
	prev_x=-1;
	prev_y=-1;
	for(int i=0;i&lt;pidx;++i)
	{
		if(X[P[i].x]==Y[P[i].y] &amp;&amp; prev_x!=P[i].x &amp;&amp; prev_y!=P[i].y)
			cout&lt;&lt;'|';
		else
			cout&lt;&lt;' ';
		prev_x=P[i].x;
		prev_y=P[i].y;
	}
	cout&lt;&lt;endl;

	// Print sequence Y
	prev_y=-1;
	for(int i=0;i&lt;pidx;++i)
	{
		if(P[i].y&lt;0 || P[i].y==prev_y)
			cout&lt;&lt;'-';
		else
			cout&lt;&lt;Y[P[i].y];
		prev_y=P[i].y;
	}
	cout&lt;&lt;endl;

}

//
// MAIN START HERE
//
int main(int argc, char** argv)
{
	// initialize random seed
	srand(time(NULL));

	char* output=NULL;	// output file
	int seqlen=0;		// sequence length
	int c;

	while ((c = getopt (argc, argv, "n:o:")) != -1)
	{
		switch (c)
           	{
		case 'n':
             		seqlen = atoi(optarg); 
             		break;
		case 'o':
             		output = optarg; 
             		break;
           	case '?':
             		if (optopt == 'n')
              			fprintf (stderr, "Option -%c requires an argument.\n\n", optopt);
             		else if (isprint (optopt))
               			fprintf (stderr, "Unknown option `-%c'.\n\n", optopt);
             		else
               			fprintf (stderr,
                        		"Unknown option character `\x%x'.\n\n",
                        		optopt);
             		return 1;
           	default:
             		abort ();
           	}
	}

	int m=seqlen;
	int n=seqlen-rand()%(seqlen/5);

	char* ref=new char[m];
	char* seq=new char[n];
	memcnt+=sizeof(char)*(m+n);

	// generate random sequences
	ref=GenRandSeq(ref,m);
	seq=GenRandSeq(seq,n);

	P=new BTNode[m+n];
	memcnt+=sizeof(BTNode)*(m+n);

	cout&lt;&lt;"seq 1:"&lt;&lt;ref&lt;&lt;endl; // TEST ONLY
	cout&lt;&lt;"seq 2:"&lt;&lt;seq&lt;&lt;endl; // TEST ONLY

	Region rx, ry;
	rx.start=0;
	rx.end=m-1;
	ry.start=0;
	ry.end=n-1;
//	Alignment(ref,rx,seq,ry); // TEST ONLY

	DivideConquerAlignment(ref,rx,seq,ry);

	Backtrace(ref,seq);

	delete [] ref;
	delete [] seq;
	delete [] P;

	// Record the space costs
	fstream fs;
	fs.open("memory_cost", fstream::out|fstream::app);
	fs&lt;&lt;m&lt;&lt;"bp: "&lt;&lt;memcnt&lt;&lt;endl;
	fs.close();

	return 0;
}</pre>


    <small class="meta">April 05, 2013 | <a href='/2013/04/05/linear-space-sequence-alignment/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/bkup/2013/03/20/implementation-of-strassens-algorithm-for-matrix-multiplication/">Implementation of Strassen's Algorithm for Matrix Multiplication</a></h2>

    <p>Strassen's algorithm is not the most efficient algorithm for matrix multiplication, but it was the first algorithm that was theoretically faster than the naive algorithm. There is very good explanation and implementation of Strassen's algorithm on <a href="http://en.wikipedia.org/wiki/Strassen_algorithm">Wikipedia</a>.</p>
<p>However, the implementation of Strassen's algorithm cannot be used directly, because it  just sets the base case of the divide-and-conquer to be 1x1 matrix, which would consume huge time cost for iteration. If set the base case to 2x2 matrix, which means 2x2 matrix and 1x1 matrix will be multiplied by naive algorithm, then the Strassen's algorithm will be more efficient for matrices larger than 512x512.</p>
<p>[caption id="attachment_521" align="alignnone" width="529"]<a href="http://bonny95.files.wordpress.com/2013/03/local_double_41.png"><img class="size-full wp-image-521" alt="When set base case to 2x2 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 512x512." src="http://bonny95.files.wordpress.com/2013/03/local_double_41.png" width="529" height="395" /></a> When set base case to 2x2 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 512x512.[/caption]</p>
<p>[caption id="attachment_520" align="alignnone" width="529"]<a href="http://bonny95.files.wordpress.com/2013/03/local_int_36.png"><img class=" wp-image-520  " alt="When set base case to 6x6 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 128x128. " src="http://bonny95.files.wordpress.com/2013/03/local_int_36.png" width="529" height="396" /></a> When set base case to 6x6 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 128x128.[/caption]</p>
<pre><code>
/*------------------------------------------------------------------------------*/
// matrix_mult.cc -- Implementation of matrix multiplication with
// Strassen's algorithm.
//
// Compile this file with gcc command:
// g++ -Wall -o matrix_mult matrix_mult.cc 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;

using namespace std;

// This function allocates the matrix
inline double** allocate_matrix(int n)
{
double** mat=new double*[n];
for(int i=0;i&lt;n;++i)
{
mat[i]=new double[n];
memset(mat[i],0,sizeof(double)*n);
}

return (mat); // returns the pointer to the vector.
}

/*------------------------------------------------------------------------------*/
// This function unallocates the matrix (frees memory)
inline void free_matrix(double **M, int n)
{
for (int i = 0; i &lt; n; i++)
{
delete [] M[i];
}

delete [] M; // frees the pointer /
M = NULL;
}

/*------------------------------------------------------------------------------*/
// function to sum two matrices
inline void sum(double **a, double **b, double **result, int tam) {

int i, j;

for (i = 0; i &lt; tam; i++) {
for (j = 0; j &lt; tam; j++) {
result[i][j] = a[i][j] + b[i][j];
}
}
}

/*------------------------------------------------------------------------------*/
// function to subtract two matrices
inline void subtract(double **a, double **b, double **result, int tam) {

int i, j;

for (i = 0; i &lt; tam; i++) {
for (j = 0; j &lt; tam; j++) {
result[i][j] = a[i][j] - b[i][j];
}
}
}

/*------------------------------------------------------------------------------*/
// naive method
void naive(double** A, double** B,double** C, int n)
{
for (int i=0;i&lt;n;i++)
for (int j=0;j&lt;n;j++)
for(int k=0;k&lt;n;k++)
C[i][j] += A[i][k]*B[k][j];
}

/*------------------------------------------------------------------------------*/
// Strassen's method
void strassen(double **a, double **b, double **c, int tam)
{
// Key observation: call naive method for matrices smaller than 2 x 2
if(tam &lt;= 4)
{
naive(a,b,c,tam);
return;
}

// other cases are treated here:
int newTam = tam/2;
double **a11, **a12, **a21, **a22;
double **b11, **b12, **b21, **b22;
double **c11, **c12, **c21, **c22;
double **p1, **p2, **p3, **p4, **p5, **p6, **p7;

// memory allocation:
a11 = allocate_matrix(newTam);
a12 = allocate_matrix(newTam);
a21 = allocate_matrix(newTam);
a22 = allocate_matrix(newTam);

b11 = allocate_matrix(newTam);
b12 = allocate_matrix(newTam);
b21 = allocate_matrix(newTam);
b22 = allocate_matrix(newTam);

c11 = allocate_matrix(newTam);
c12 = allocate_matrix(newTam);
c21 = allocate_matrix(newTam);
c22 = allocate_matrix(newTam);

p1 = allocate_matrix(newTam);
p2 = allocate_matrix(newTam);
p3 = allocate_matrix(newTam);
p4 = allocate_matrix(newTam);
p5 = allocate_matrix(newTam);
p6 = allocate_matrix(newTam);
p7 = allocate_matrix(newTam);

double **aResult = allocate_matrix(newTam);
double **bResult = allocate_matrix(newTam);

//dividing the matrices in 4 sub-matrices:
for (int i = 0; i &lt; newTam; i++) {
for (int j = 0; j &lt; newTam; j++) {
a11[i][j] = a[i][j];
a12[i][j] = a[i][j + newTam];
a21[i][j] = a[i + newTam][j];
a22[i][j] = a[i + newTam][j + newTam];

b11[i][j] = b[i][j];
b12[i][j] = b[i][j + newTam];
b21[i][j] = b[i + newTam][j];
b22[i][j] = b[i + newTam][j + newTam];
}
}

// Calculating p1 to p7:

sum(a11, a22, aResult, newTam); // a11 + a22
sum(b11, b22, bResult, newTam); // b11 + b22
strassen(aResult, bResult, p1, newTam); // p1 = (a11+a22) * (b11+b22)

sum(a21, a22, aResult, newTam); // a21 + a22
strassen(aResult, b11, p2, newTam); // p2 = (a21+a22) * (b11)

subtract(b12, b22, bResult, newTam); // b12 - b22
strassen(a11, bResult, p3, newTam); // p3 = (a11) * (b12 - b22)

subtract(b21, b11, bResult, newTam); // b21 - b11
strassen(a22, bResult, p4, newTam); // p4 = (a22) * (b21 - b11)

sum(a11, a12, aResult, newTam); // a11 + a12
strassen(aResult, b22, p5, newTam); // p5 = (a11+a12) * (b22)

subtract(a21, a11, aResult, newTam); // a21 - a11
sum(b11, b12, bResult, newTam); // b11 + b12
strassen(aResult, bResult, p6, newTam); // p6 = (a21-a11) * (b11+b12)

subtract(a12, a22, aResult, newTam); // a12 - a22
sum(b21, b22, bResult, newTam); // b21 + b22
strassen(aResult, bResult, p7, newTam); // p7 = (a12-a22) * (b21+b22)

// calculating c21, c21, c11 e c22:

sum(p3, p5, c12, newTam); // c12 = p3 + p5
sum(p2, p4, c21, newTam); // c21 = p2 + p4

sum(p1, p4, aResult, newTam); // p1 + p4
sum(aResult, p7, bResult, newTam); // p1 + p4 + p7
subtract(bResult, p5, c11, newTam); // c11 = p1 + p4 - p5 + p7

sum(p1, p3, aResult, newTam); // p1 + p3
sum(aResult, p6, bResult, newTam); // p1 + p3 + p6
subtract(bResult, p2, c22, newTam); // c22 = p1 + p3 - p2 + p6

// Grouping the results obtained in a single matrix:
for (int i = 0; i &lt; newTam ; i++) {
for (int j = 0 ; j &lt; newTam ; j++) {
c[i][j] = c11[i][j];
c[i][j + newTam] = c12[i][j];
c[i + newTam][j] = c21[i][j];
c[i + newTam][j + newTam] = c22[i][j];
}
}

// deallocating memory (free):
free_matrix(a11, newTam);
free_matrix(a12, newTam);
free_matrix(a21, newTam);
free_matrix(a22, newTam);

free_matrix(b11, newTam);
free_matrix(b12, newTam);
free_matrix(b21, newTam);
free_matrix(b22, newTam);

free_matrix(c11, newTam);
free_matrix(c12, newTam);
free_matrix(c21, newTam);
free_matrix(c22, newTam);

free_matrix(p1, newTam);
free_matrix(p2, newTam);
free_matrix(p3, newTam);
free_matrix(p4, newTam);
free_matrix(p5, newTam);
free_matrix(p6, newTam);
free_matrix(p7, newTam);
free_matrix(aResult, newTam);
free_matrix(bResult, newTam);

} // end of Strassen function

/*------------------------------------------------------------------------------*/
// Generate random matrices
void gen_matrix(double** M,int n)
{
for(int i=0;i&lt;n;++i)
{
for(int j=0;j&lt;n;++j)
{
M[i][j]=rand()%100;
//M[i][j]=1;
}
}
}

/*------------------------------------------------------------------------------*/
// print matrix M using specied fstream
void print_matrix(fstream&amp; fs, double** M, int n)
{
for(int i=0;i&lt;n;++i)
{
for(int j=0;j&lt;n;++j)
{
fs&lt;&lt;M[i][j]&lt;&lt;" ";
}
fs&lt;&lt;endl;
}
fs&lt;&lt;endl;
}

/*------------------------------------------------------------------------------*/
// record the generated matrix and the final product
void mat_mult_log(double** A, double** B,double** C,int n,char* file)
{
fstream fs;
fs.open(file,fstream::out);

fs&lt;&lt;"Random Matrix A:"&lt;&lt;endl;
print_matrix(fs,A,n);
fs&lt;&lt;"Random Matrix B:"&lt;&lt;endl;
print_matrix(fs,B,n);
fs&lt;&lt;"C=A * B"&lt;&lt;endl;
print_matrix(fs,C,n);

fs.close();
}

/*------------------------------------------------------------------------------*/

int main(int argc, char** argv)
{
srand(time(NULL));

int mdim=2; // matrix dimension
char* output=NULL;
bool is_strassen=false;
int c;

while ((c = getopt (argc, argv, "sn:o:")) != -1)
{
switch (c)
{
case 's':
is_strassen=true;
break;
case 'n':
mdim = pow((int)2,atoi(optarg)); // 2^n dimensions
break;
case 'o':
output = optarg; // 2^n dimensions
break;
case '?':
if (optopt == 'n')
fprintf (stderr, "Option -%c requires an argument.\n", optopt);
else if (isprint (optopt))
fprintf (stderr, "Unknown option `-%c'.\n", optopt);
else
fprintf (stderr,
"Unknown option character `\x%x'.\n",
optopt);
return 1;
default:
abort ();
}
}

// create new matrices
double** A=allocate_matrix(mdim);
double** B=allocate_matrix(mdim);
double** C=allocate_matrix(mdim);
gen_matrix(A,mdim);
gen_matrix(B,mdim);

// matrices multiplication
if(is_strassen)
strassen(A,B,C,mdim);
else
naive(A,B,C,mdim);

if(output!=NULL)
mat_mult_log(A,B,C,mdim,output);

free_matrix(A,mdim);
free_matrix(B,mdim);
free_matrix(C,mdim);

return 0;
}</code></pre>


    <small class="meta">March 20, 2013 | <a href='/bkup/2013/03/20/implementation-of-strassens-algorithm-for-matrix-multiplication/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/2013/03/20/implementation-of-strassens-algorithm-for-matrix-multiplication/">Implementation of Strassen's Algorithm for Matrix Multiplication</a></h2>

    <p>Strassen's algorithm is not the most efficient algorithm for matrix multiplication, but it was the first algorithm that was theoretically faster than the naive algorithm. There is very good explanation and implementation of Strassen's algorithm on <a href="http://en.wikipedia.org/wiki/Strassen_algorithm">Wikipedia</a>.</p>
<p>However, the implementation of Strassen's algorithm cannot be used directly, because it  just sets the base case of the divide-and-conquer to be 1x1 matrix, which would consume huge time cost for iteration. If set the base case to 2x2 matrix, which means 2x2 matrix and 1x1 matrix will be multiplied by naive algorithm, then the Strassen's algorithm will be more efficient for matrices larger than 512x512.</p>
<p>[caption id="attachment_521" align="alignnone" width="529"]<a href="http://bonny95.files.wordpress.com/2013/03/local_double_41.png"><img class="size-full wp-image-521" alt="When set base case to 2x2 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 512x512." src="http://bonny95.files.wordpress.com/2013/03/local_double_41.png" width="529" height="395" /></a> When set base case to 2x2 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 512x512.[/caption]</p>
<p>[caption id="attachment_520" align="alignnone" width="529"]<a href="http://bonny95.files.wordpress.com/2013/03/local_int_36.png"><img class=" wp-image-520  " alt="When set base case to 6x6 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 128x128. " src="http://bonny95.files.wordpress.com/2013/03/local_int_36.png" width="529" height="396" /></a> When set base case to 6x6 matrix, then the Strassen's algorithm will surpass naive algorithm for matrices larger than 128x128.[/caption]</p>
<pre><code>
/*------------------------------------------------------------------------------*/
// matrix_mult.cc -- Implementation of matrix multiplication with
// Strassen's algorithm.
//
// Compile this file with gcc command:
// g++ -Wall -o matrix_mult matrix_mult.cc 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;

using namespace std;

// This function allocates the matrix
inline double** allocate_matrix(int n)
{
double** mat=new double*[n];
for(int i=0;i&lt;n;++i)
{
mat[i]=new double[n];
memset(mat[i],0,sizeof(double)*n);
}

return (mat); // returns the pointer to the vector.
}

/*------------------------------------------------------------------------------*/
// This function unallocates the matrix (frees memory)
inline void free_matrix(double **M, int n)
{
for (int i = 0; i &lt; n; i++)
{
delete [] M[i];
}

delete [] M; // frees the pointer /
M = NULL;
}

/*------------------------------------------------------------------------------*/
// function to sum two matrices
inline void sum(double **a, double **b, double **result, int tam) {

int i, j;

for (i = 0; i &lt; tam; i++) {
for (j = 0; j &lt; tam; j++) {
result[i][j] = a[i][j] + b[i][j];
}
}
}

/*------------------------------------------------------------------------------*/
// function to subtract two matrices
inline void subtract(double **a, double **b, double **result, int tam) {

int i, j;

for (i = 0; i &lt; tam; i++) {
for (j = 0; j &lt; tam; j++) {
result[i][j] = a[i][j] - b[i][j];
}
}
}

/*------------------------------------------------------------------------------*/
// naive method
void naive(double** A, double** B,double** C, int n)
{
for (int i=0;i&lt;n;i++)
for (int j=0;j&lt;n;j++)
for(int k=0;k&lt;n;k++)
C[i][j] += A[i][k]*B[k][j];
}

/*------------------------------------------------------------------------------*/
// Strassen's method
void strassen(double **a, double **b, double **c, int tam)
{
// Key observation: call naive method for matrices smaller than 2 x 2
if(tam &lt;= 4)
{
naive(a,b,c,tam);
return;
}

// other cases are treated here:
int newTam = tam/2;
double **a11, **a12, **a21, **a22;
double **b11, **b12, **b21, **b22;
double **c11, **c12, **c21, **c22;
double **p1, **p2, **p3, **p4, **p5, **p6, **p7;

// memory allocation:
a11 = allocate_matrix(newTam);
a12 = allocate_matrix(newTam);
a21 = allocate_matrix(newTam);
a22 = allocate_matrix(newTam);

b11 = allocate_matrix(newTam);
b12 = allocate_matrix(newTam);
b21 = allocate_matrix(newTam);
b22 = allocate_matrix(newTam);

c11 = allocate_matrix(newTam);
c12 = allocate_matrix(newTam);
c21 = allocate_matrix(newTam);
c22 = allocate_matrix(newTam);

p1 = allocate_matrix(newTam);
p2 = allocate_matrix(newTam);
p3 = allocate_matrix(newTam);
p4 = allocate_matrix(newTam);
p5 = allocate_matrix(newTam);
p6 = allocate_matrix(newTam);
p7 = allocate_matrix(newTam);

double **aResult = allocate_matrix(newTam);
double **bResult = allocate_matrix(newTam);

//dividing the matrices in 4 sub-matrices:
for (int i = 0; i &lt; newTam; i++) {
for (int j = 0; j &lt; newTam; j++) {
a11[i][j] = a[i][j];
a12[i][j] = a[i][j + newTam];
a21[i][j] = a[i + newTam][j];
a22[i][j] = a[i + newTam][j + newTam];

b11[i][j] = b[i][j];
b12[i][j] = b[i][j + newTam];
b21[i][j] = b[i + newTam][j];
b22[i][j] = b[i + newTam][j + newTam];
}
}

// Calculating p1 to p7:

sum(a11, a22, aResult, newTam); // a11 + a22
sum(b11, b22, bResult, newTam); // b11 + b22
strassen(aResult, bResult, p1, newTam); // p1 = (a11+a22) * (b11+b22)

sum(a21, a22, aResult, newTam); // a21 + a22
strassen(aResult, b11, p2, newTam); // p2 = (a21+a22) * (b11)

subtract(b12, b22, bResult, newTam); // b12 - b22
strassen(a11, bResult, p3, newTam); // p3 = (a11) * (b12 - b22)

subtract(b21, b11, bResult, newTam); // b21 - b11
strassen(a22, bResult, p4, newTam); // p4 = (a22) * (b21 - b11)

sum(a11, a12, aResult, newTam); // a11 + a12
strassen(aResult, b22, p5, newTam); // p5 = (a11+a12) * (b22)

subtract(a21, a11, aResult, newTam); // a21 - a11
sum(b11, b12, bResult, newTam); // b11 + b12
strassen(aResult, bResult, p6, newTam); // p6 = (a21-a11) * (b11+b12)

subtract(a12, a22, aResult, newTam); // a12 - a22
sum(b21, b22, bResult, newTam); // b21 + b22
strassen(aResult, bResult, p7, newTam); // p7 = (a12-a22) * (b21+b22)

// calculating c21, c21, c11 e c22:

sum(p3, p5, c12, newTam); // c12 = p3 + p5
sum(p2, p4, c21, newTam); // c21 = p2 + p4

sum(p1, p4, aResult, newTam); // p1 + p4
sum(aResult, p7, bResult, newTam); // p1 + p4 + p7
subtract(bResult, p5, c11, newTam); // c11 = p1 + p4 - p5 + p7

sum(p1, p3, aResult, newTam); // p1 + p3
sum(aResult, p6, bResult, newTam); // p1 + p3 + p6
subtract(bResult, p2, c22, newTam); // c22 = p1 + p3 - p2 + p6

// Grouping the results obtained in a single matrix:
for (int i = 0; i &lt; newTam ; i++) {
for (int j = 0 ; j &lt; newTam ; j++) {
c[i][j] = c11[i][j];
c[i][j + newTam] = c12[i][j];
c[i + newTam][j] = c21[i][j];
c[i + newTam][j + newTam] = c22[i][j];
}
}

// deallocating memory (free):
free_matrix(a11, newTam);
free_matrix(a12, newTam);
free_matrix(a21, newTam);
free_matrix(a22, newTam);

free_matrix(b11, newTam);
free_matrix(b12, newTam);
free_matrix(b21, newTam);
free_matrix(b22, newTam);

free_matrix(c11, newTam);
free_matrix(c12, newTam);
free_matrix(c21, newTam);
free_matrix(c22, newTam);

free_matrix(p1, newTam);
free_matrix(p2, newTam);
free_matrix(p3, newTam);
free_matrix(p4, newTam);
free_matrix(p5, newTam);
free_matrix(p6, newTam);
free_matrix(p7, newTam);
free_matrix(aResult, newTam);
free_matrix(bResult, newTam);

} // end of Strassen function

/*------------------------------------------------------------------------------*/
// Generate random matrices
void gen_matrix(double** M,int n)
{
for(int i=0;i&lt;n;++i)
{
for(int j=0;j&lt;n;++j)
{
M[i][j]=rand()%100;
//M[i][j]=1;
}
}
}

/*------------------------------------------------------------------------------*/
// print matrix M using specied fstream
void print_matrix(fstream&amp; fs, double** M, int n)
{
for(int i=0;i&lt;n;++i)
{
for(int j=0;j&lt;n;++j)
{
fs&lt;&lt;M[i][j]&lt;&lt;" ";
}
fs&lt;&lt;endl;
}
fs&lt;&lt;endl;
}

/*------------------------------------------------------------------------------*/
// record the generated matrix and the final product
void mat_mult_log(double** A, double** B,double** C,int n,char* file)
{
fstream fs;
fs.open(file,fstream::out);

fs&lt;&lt;"Random Matrix A:"&lt;&lt;endl;
print_matrix(fs,A,n);
fs&lt;&lt;"Random Matrix B:"&lt;&lt;endl;
print_matrix(fs,B,n);
fs&lt;&lt;"C=A * B"&lt;&lt;endl;
print_matrix(fs,C,n);

fs.close();
}

/*------------------------------------------------------------------------------*/

int main(int argc, char** argv)
{
srand(time(NULL));

int mdim=2; // matrix dimension
char* output=NULL;
bool is_strassen=false;
int c;

while ((c = getopt (argc, argv, "sn:o:")) != -1)
{
switch (c)
{
case 's':
is_strassen=true;
break;
case 'n':
mdim = pow((int)2,atoi(optarg)); // 2^n dimensions
break;
case 'o':
output = optarg; // 2^n dimensions
break;
case '?':
if (optopt == 'n')
fprintf (stderr, "Option -%c requires an argument.\n", optopt);
else if (isprint (optopt))
fprintf (stderr, "Unknown option `-%c'.\n", optopt);
else
fprintf (stderr,
"Unknown option character `\x%x'.\n",
optopt);
return 1;
default:
abort ();
}
}

// create new matrices
double** A=allocate_matrix(mdim);
double** B=allocate_matrix(mdim);
double** C=allocate_matrix(mdim);
gen_matrix(A,mdim);
gen_matrix(B,mdim);

// matrices multiplication
if(is_strassen)
strassen(A,B,C,mdim);
else
naive(A,B,C,mdim);

if(output!=NULL)
mat_mult_log(A,B,C,mdim,output);

free_matrix(A,mdim);
free_matrix(B,mdim);
free_matrix(C,mdim);

return 0;
}</code></pre>


    <small class="meta">March 20, 2013 | <a href='/2013/03/20/implementation-of-strassens-algorithm-for-matrix-multiplication/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/bkup/2013/01/29/basic-linux-multi-process-multi-thread-programming/">Basic Linux Multi-Process & Multi-Thread Programming</a></h2>

    <p>
	Today I have to make my algorithm running in parallel in order to make it faster. At first I used following way to implement multi-process:</p>
<pre class="cpp">	unsigned int proc_num = 5;
	pid_t* pids=new pid_t[proc_num];
	double incr=(double)N/(double)proc_num;
	
	/* Start children. */
	for (unsigned int i = 0; i &lt; proc_num; ++i) {
		if ((pids[i] = fork()) &lt; 0) {
	    		perror(&quot;fork&quot;);
	    		abort();
	 	} else if (pids[i] == 0) {
	    		// DoWorkInChild();

	    		exit(0);
	  	}
	}
	
	/* Wait for children to exit. */
	int status;
	pid_t pid;
	while (proc_num &gt; 0) {
	  	pid = wait(&amp;status);
		if(status != 0)
	  		printf(&quot;Child Process with PID %ld aborted with status 0x%x.\n&quot;, (long)pid, status);
	  	--proc_num;  // TODO(pts): Remove pid from the pids array.
	}
</pre>
<p>
Above way worked well, however, there's no way to change the &quot;shared&quot; variables in child processes. Because each child process has an independent copy of all variables.</p>
<p>
	In order to change the same array in parallel, I implemented multi threads.</p></p>
<pre class="cpp">struct thread_info {    /* Used as argument to thread_start() */
	pthread_t thread_id;        /* ID returned by pthread_create() */
	int	start;       /* Application-defined thread # */
	int     end;      /* From command-line argument */
	int*	gpdarr;	/* Array to store GPD number */
	long int G;	/* genome length */
	unsigned int L;	/* read length */
	double l1;	// GPD parameter lambda1
	double l2;	// GPD parameter lambda2
	double M;	// maximum of GPD density
};

void printPt(pthread_t pt) {
  unsigned char *ptc = (unsigned char*)(void*)(&amp;pt);
  printf(&quot;0x&quot;);
  for (size_t i=0; i&lt;sizeof(pt); i++) {
    printf(&quot;%02x&quot;, (unsigned)(ptc[i]));
  }
}

void* gen_gpd_num(void* arg)
{
	struct thread_info *tinfo = (struct thread_info *) arg;
	// do something here

	pthread_exit(0);
}

int main()
{
        unsigned int tnum = 20;
	double incr=(double)N/(double)tnum;
	
	thread_info* tinfo=new thread_info[tnum];

	int err;
	void* res;
	
	/* Start children. */
	for(unsigned int idx=0;idx&lt;tnum;++idx) 
	{
		tinfo[idx].start=incr*idx;
		tinfo[idx].end=incr*(idx+1);
		tinfo[idx].gpdarr=gpdnum;
		tinfo[idx].G=G;
		tinfo[idx].L=l;
		tinfo[idx].l1=l1;
		tinfo[idx].l2=l2;
		tinfo[idx].M=M;

		err = pthread_create(&amp;tinfo[idx].thread_id, NULL, &amp;gen_gpd_num, &amp;tinfo[idx]);

		if(err!=0)
			printf(&quot;can't create thread :[%s]&quot;, strerror(err));
		else
			pthread_join(tinfo[idx].thread_id, &amp;res);
	}
        delete [] tinfo;
}</pre>
<p>
The potential problem of using multi-threading in Linux is -- it is hard to figure out if there really are many threads are running&nbsp;simultaneously.&nbsp;</p>
<p>
	When compiling multi-threading program using GCC, pthread library must be specified:</p></p>
<pre class="cpp">g++ -o foo -Wall foo.cc -L/usr/lib -lpthread</pre>
<p>
References:</p></p>
<ol>
<li>
		<a href="http://www.thegeekstuff.com/2012/04/create-threads-in-linux/" style="font-size:14px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;letter-spacing:-1px;line-height:1.364em;">How to Create Threads in Linux (With a C Example Program)</a></p>
<h1 class="entry-title" style="padding:0;margin:0;font-weight:normal;color:rgb(169,0,0);line-height:1.364em;letter-spacing:-1px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;">
		</h1>
</li>
<li>
		http://www.kernel.org/doc/man-pages/online/pages/man3/pthread_create.3.html</p>
</li>
</ol></p>
<p>
	</p>


    <small class="meta">January 29, 2013 | <a href='/bkup/2013/01/29/basic-linux-multi-process-multi-thread-programming/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/2013/01/29/basic-linux-multi-process-multi-thread-programming/">Basic Linux Multi-Process & Multi-Thread Programming</a></h2>

    <p>
	Today I have to make my algorithm running in parallel in order to make it faster. At first I used following way to implement multi-process:</p>
<pre class="cpp">	unsigned int proc_num = 5;
	pid_t* pids=new pid_t[proc_num];
	double incr=(double)N/(double)proc_num;
	
	/* Start children. */
	for (unsigned int i = 0; i &lt; proc_num; ++i) {
		if ((pids[i] = fork()) &lt; 0) {
	    		perror(&quot;fork&quot;);
	    		abort();
	 	} else if (pids[i] == 0) {
	    		// DoWorkInChild();

	    		exit(0);
	  	}
	}
	
	/* Wait for children to exit. */
	int status;
	pid_t pid;
	while (proc_num &gt; 0) {
	  	pid = wait(&amp;status);
		if(status != 0)
	  		printf(&quot;Child Process with PID %ld aborted with status 0x%x.\n&quot;, (long)pid, status);
	  	--proc_num;  // TODO(pts): Remove pid from the pids array.
	}
</pre>
<p>
Above way worked well, however, there's no way to change the &quot;shared&quot; variables in child processes. Because each child process has an independent copy of all variables.</p>
<p>
	In order to change the same array in parallel, I implemented multi threads.</p></p>
<pre class="cpp">struct thread_info {    /* Used as argument to thread_start() */
	pthread_t thread_id;        /* ID returned by pthread_create() */
	int	start;       /* Application-defined thread # */
	int     end;      /* From command-line argument */
	int*	gpdarr;	/* Array to store GPD number */
	long int G;	/* genome length */
	unsigned int L;	/* read length */
	double l1;	// GPD parameter lambda1
	double l2;	// GPD parameter lambda2
	double M;	// maximum of GPD density
};

void printPt(pthread_t pt) {
  unsigned char *ptc = (unsigned char*)(void*)(&amp;pt);
  printf(&quot;0x&quot;);
  for (size_t i=0; i&lt;sizeof(pt); i++) {
    printf(&quot;%02x&quot;, (unsigned)(ptc[i]));
  }
}

void* gen_gpd_num(void* arg)
{
	struct thread_info *tinfo = (struct thread_info *) arg;
	// do something here

	pthread_exit(0);
}

int main()
{
        unsigned int tnum = 20;
	double incr=(double)N/(double)tnum;
	
	thread_info* tinfo=new thread_info[tnum];

	int err;
	void* res;
	
	/* Start children. */
	for(unsigned int idx=0;idx&lt;tnum;++idx) 
	{
		tinfo[idx].start=incr*idx;
		tinfo[idx].end=incr*(idx+1);
		tinfo[idx].gpdarr=gpdnum;
		tinfo[idx].G=G;
		tinfo[idx].L=l;
		tinfo[idx].l1=l1;
		tinfo[idx].l2=l2;
		tinfo[idx].M=M;

		err = pthread_create(&amp;tinfo[idx].thread_id, NULL, &amp;gen_gpd_num, &amp;tinfo[idx]);

		if(err!=0)
			printf(&quot;can't create thread :[%s]&quot;, strerror(err));
		else
			pthread_join(tinfo[idx].thread_id, &amp;res);
	}
        delete [] tinfo;
}</pre>
<p>
The potential problem of using multi-threading in Linux is -- it is hard to figure out if there really are many threads are running&nbsp;simultaneously.&nbsp;</p>
<p>
	When compiling multi-threading program using GCC, pthread library must be specified:</p></p>
<pre class="cpp">g++ -o foo -Wall foo.cc -L/usr/lib -lpthread</pre>
<p>
References:</p></p>
<ol>
<li>
		<a href="http://www.thegeekstuff.com/2012/04/create-threads-in-linux/" style="font-size:14px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;letter-spacing:-1px;line-height:1.364em;">How to Create Threads in Linux (With a C Example Program)</a></p>
<h1 class="entry-title" style="padding:0;margin:0;font-weight:normal;color:rgb(169,0,0);line-height:1.364em;letter-spacing:-1px;font-family:'Helvetica Neue', Helvetica, Arial, sans-serif;">
		</h1>
</li>
<li>
		http://www.kernel.org/doc/man-pages/online/pages/man3/pthread_create.3.html</p>
</li>
</ol></p>
<p>
	</p>


    <small class="meta">January 29, 2013 | <a href='/2013/01/29/basic-linux-multi-process-multi-thread-programming/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/2012/12/06/simple-matlaboctave-commands-to-process-data/">Simple Matlab/Octave Commands to Process Data</a></h2>

    <p>To load data in following format stored in a text file "read_pos' into Matlab/Octave, use commands<br />
<code><br />
    f=fopen('read_pos','r'); % open file<br />
    a=textscan(f,'%s%d');  % read file<br />
    y=a{2}; % a is a cell: a{1} stores read id, a{2} stores numbers.<br />
</code><br />
<br />
Then data of the second column are stored in variable y.<br />
<code><br />
r12353.1 	2407054.5<br />
r12361.1 	5328858.5<br />
r12363.1 	2360272<br />
r12368.1 	4726440.5<br />
r12372.1 	2224001<br />
r12373.1 	5165613.5<br />
r12381.1 	501776<br />
r12385.1 	3475398<br />
r12394.1 	3376364<br />
r12401.1 	2142875.5<br />
r12411.1 	2191090.5<br />
r12419.1 	1240590<br />
r12420.1 	4903572<br />
r12422.1 	767011.5<br />
r12426.1 	3575915.5<br />
r12429.1 	554956<br />
r12433.1 	4786335<br />
r12435.1 	3373955.5<br />
r12442.1 	5363611.5<br />
r12452.1 	1903660.5<br />
r12454.1 	2784165<br />
r12466.1 	5137479<br />
r12470.1 	592191<br />
</code><br />
<br />
If there are only numbers stored in file "read_pos", following commands should be used:<br />
<code><br />
    f=fopen('read_pos','r'); % open file<br />
    a=textscan(f,'%s%d');  % read file<br />
    y=cell2mat{a}; % convert cell a to vector<br />
    size(y) % check the size<br />
</code></p>
<p>
To plot the distribution of all the numbers, you can:<br />
<code><br />
    x=zeros(size(y));<br />
    plot(y,x,'bo');<br />
</code><br />
<br />
If another data set z is also loaded and you want to plot y and z in the same graph, you can:<br />
<code><br />
    figure<br />
    x=zeros(size(y));<br />
    plot(y,x,'bo');<br />
    hold on<br />
    x=ones(size(z));<br />
    plot(z,x,'r+');<br />
</code></p>
<p>
To annotate and scale the graph, use commands;<br />
<code><br />
    xlabel('AMD Data k-mer Occurrances');<br />
    title('GPD Classification of AMD k-mers')<br />
    legend('Bin 1','Bin 2')<br />
    axis([-5 5 0 10000]) % scale axes<br />
</code></p>
<p>A matlab function to plot multiple datasets:<br />
<code><br />
function result=plot_distr(varargin)</p>
<p>nVarargs=length(varargin);</p>
<p>marker={'bo' 'r+' 'k*' 'gs' 'y^' 'md' 'cp' 'bx' 'r.' 'k&gt;' 'gh' 'y&lt;&#039;};<br />
figure<br />
for k=1:nVarargs<br />
	f=fopen(varargin{k},&#039;r&#039;);<br />
	a=textscan(f,&#039;%d&#039;);<br />
	y=cell2mat(a);<br />
	x=zeros(size(y))+k;<br />
	plot(y,x,marker{k});<br />
	hold on<br />
end<br />
ylim([0-5*nVarargs 6*nVarargs]); % scale y-axis<br />
</code></p>


    <small class="meta">December 06, 2012 | <a href='/2012/12/06/simple-matlaboctave-commands-to-process-data/#disqus_thread'>View Comments</a></small>
  </div>

  <div class="post">
    <h2><a href="/bkup/2012/12/06/simple-matlaboctave-commands-to-process-data/">Simple Matlab/Octave Commands to Process Data</a></h2>

    <p>To load data in following format stored in a text file "read_pos' into Matlab/Octave, use commands<br />
<code><br />
    f=fopen('read_pos','r'); % open file<br />
    a=textscan(f,'%s%d');  % read file<br />
    y=a{2}; % a is a cell: a{1} stores read id, a{2} stores numbers.<br />
</code><br />
<br />
Then data of the second column are stored in variable y.<br />
<code><br />
r12353.1 	2407054.5<br />
r12361.1 	5328858.5<br />
r12363.1 	2360272<br />
r12368.1 	4726440.5<br />
r12372.1 	2224001<br />
r12373.1 	5165613.5<br />
r12381.1 	501776<br />
r12385.1 	3475398<br />
r12394.1 	3376364<br />
r12401.1 	2142875.5<br />
r12411.1 	2191090.5<br />
r12419.1 	1240590<br />
r12420.1 	4903572<br />
r12422.1 	767011.5<br />
r12426.1 	3575915.5<br />
r12429.1 	554956<br />
r12433.1 	4786335<br />
r12435.1 	3373955.5<br />
r12442.1 	5363611.5<br />
r12452.1 	1903660.5<br />
r12454.1 	2784165<br />
r12466.1 	5137479<br />
r12470.1 	592191<br />
</code><br />
<br />
If there are only numbers stored in file "read_pos", following commands should be used:<br />
<code><br />
    f=fopen('read_pos','r'); % open file<br />
    a=textscan(f,'%s%d');  % read file<br />
    y=cell2mat{a}; % convert cell a to vector<br />
    size(y) % check the size<br />
</code></p>
<p>
To plot the distribution of all the numbers, you can:<br />
<code><br />
    x=zeros(size(y));<br />
    plot(y,x,'bo');<br />
</code><br />
<br />
If another data set z is also loaded and you want to plot y and z in the same graph, you can:<br />
<code><br />
    figure<br />
    x=zeros(size(y));<br />
    plot(y,x,'bo');<br />
    hold on<br />
    x=ones(size(z));<br />
    plot(z,x,'r+');<br />
</code></p>
<p>
To annotate and scale the graph, use commands;<br />
<code><br />
    xlabel('AMD Data k-mer Occurrances');<br />
    title('GPD Classification of AMD k-mers')<br />
    legend('Bin 1','Bin 2')<br />
    axis([-5 5 0 10000]) % scale axes<br />
</code></p>
<p>A matlab function to plot multiple datasets:<br />
<code><br />
function result=plot_distr(varargin)</p>
<p>nVarargs=length(varargin);</p>
<p>marker={'bo' 'r+' 'k*' 'gs' 'y^' 'md' 'cp' 'bx' 'r.' 'k&gt;' 'gh' 'y&lt;&#039;};<br />
figure<br />
for k=1:nVarargs<br />
	f=fopen(varargin{k},&#039;r&#039;);<br />
	a=textscan(f,&#039;%d&#039;);<br />
	y=cell2mat(a);<br />
	x=zeros(size(y))+k;<br />
	plot(y,x,marker{k});<br />
	hold on<br />
end<br />
ylim([0-5*nVarargs 6*nVarargs]); % scale y-axis<br />
</code></p>


    <small class="meta">December 06, 2012 | <a href='/bkup/2012/12/06/simple-matlaboctave-commands-to-process-data/#disqus_thread'>View Comments</a></small>
  </div>

</div>

<div class='paging'>
  
    <a href='/page4' class='older'>Older Posts</a>
  

  
    <a href='/page2' class='newer'>Newer Posts</a>
  

  
  <div class='clear'></div>
</div>

        </div>
      </div>

      <div id="bottom" class="span8 offset4">
        <div class="well">
          <a href="/about/">About</a> |
          <a href="/archives/">Archives</a> |
          <a href="/atom.xml">feed</a>
        </div>
      </div>
    </div>
  </div>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script src="/javascripts/bootstrap.min.js"></script>

  <!-- Google Analytics Code -->
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-9947336-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script');
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 
          'http://www') + '.google-analytics.com/ga.js';
      ga.setAttribute('async', 'true');
      document.documentElement.firstChild.appendChild(ga);
    })();

  </script>
</body>
</html>

